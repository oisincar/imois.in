<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>im_oisin (Game Development)</title><link>https://imois.in/</link><description></description><atom:link href="https://imois.in/categories/gamedev.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2022 &lt;a href="mailto:oisincar@gmail.com"&gt;Oisin Carroll&lt;/a&gt; </copyright><lastBuildDate>Sat, 17 Dec 2022 19:14:22 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Slapshot: Rebound Bots. Pt 1: Signed Distance Field Lookups</title><link>https://imois.in/posts/slapshot-sdf-physics/</link><dc:creator>Oisin Carroll</dc:creator><description>&lt;div id="outline-container-orgf35df52" class="outline-2"&gt;
&lt;h2 id="orgf35df52"&gt;Introduction&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf35df52"&gt;
&lt;script type="text/javascript" src="https://unpkg.com/vis-graph3d@latest/dist/vis-graph3d.min.js"&gt;&lt;/script&gt;&lt;script src="https://imois.in/assets/js/slapshot/slapshot_sdf_graph.js"&gt;&lt;/script&gt;&lt;script src="https://imois.in/assets/js/math/Vector.js"&gt;&lt;/script&gt;&lt;p&gt;
Earlier in the year I developed the AI for Slapshot: Rebound: A physics-based, surprisingly tricky and fast paced ice hockey game. The bots navigate the rink, pass and shoot. They have human-like reaction times, and can play together as a team or drop in as a replacement should a player disconnect in an online match. They also handily outplay me at the game, although that's not much of an achievement.
&lt;/p&gt;


&lt;div id="org20e9a13" class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/slapshot/slapshot_bots_demo.gif" alt="slapshot_bots_demo.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 1: &lt;/span&gt;A some gameplay from a 2v2 game in slapshot. All players are bots.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
This first part covers a novel method for how the bots handle spacial queries, and perform some physics-based predictions.
&lt;/p&gt;

&lt;p&gt;
Something that came up repeatedly is 'how far is this point from the edge?'. I wanted to move bots away from the edges to put them in the action, and bots needed to know if the puck was near the edge so they could approach it correctly. Additionally, it was important to quickly check if points were in bounds, so the bots weren't attempting to skate into the wall.
&lt;/p&gt;

&lt;p&gt;
The problem surfaces again when considering more advanced behaviours: The bots simulate puck rebounds off the rink and goals, and predict accordingly. Knowing where and when the puck would collide is a difficult problem.
&lt;/p&gt;

&lt;p&gt;
It's possible to use lots of raycasts to check for nearby obstacles, but this gets expensive. For predicting puck paths, the solution used by the open source &lt;a href="https://rlbot.org"&gt;Rocket League Bots&lt;/a&gt; I looked at is to use a full physics engine: Bullet, to occasionally simulate the ball path and interaction with objects. This is very accurate, but it's slow and complicated.
&lt;/p&gt;

&lt;p&gt;
Instead, I used an idea from graphics: Signed Distance Functions. It's much faster, and (approximately) handles all of the above in just ~50 lines of code.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf62a864" class="outline-2"&gt;
&lt;h2 id="orgf62a864"&gt;What is a Signed Distance Function?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf62a864"&gt;
&lt;p&gt;
The idea of a signed distance field is to provide a function \(f(\vec{p}) = d\) which gives the distance from some point \(p\) to a surface.
&lt;/p&gt;

&lt;p&gt;
The signed distance function (SDF) for a circle of radius \(r\) centered on the origin is:
&lt;/p&gt;

&lt;p&gt;
\[
\mathit{sdf\_circle}(\vec{p}) = \lVert \vec{p} \rVert - \vec{r};
\]
&lt;/p&gt;

&lt;p&gt;
This is shown in Plot 1, below. Click and drag to pan, scroll to zoom.
&lt;/p&gt;

&lt;div class="figure" style="width: auto"&gt;
  &lt;div id="mygraph" style="max-width: 85vw;"&gt;&lt;/div&gt;
  &lt;p&gt;&lt;span class="figure-number"&gt;Plot 1:&lt;/span&gt;
    The signed distance function for a circle with radius 1. The function is negative inside the shape, and positive elsewhere. Where the function is 0 denotes the perimiter of the circle.
  &lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;

function sdf_circle_r1(x, y) {
    var v = new Vector(x, y);
    return v.getLength() - 1;
}

this.graph = new SDFGraph(document.getElementById('mygraph'),
                          sdf_circle_r1,
                          3,
                          3,
                          50);
&lt;/script&gt;&lt;p&gt;
Where things get interesting though is combining SDFs. You can take the \(min\) of two functions to find the intersection of two shapes, and \(max\) to find the union.
&lt;/p&gt;

&lt;p&gt;
You can also negate a function to find the inverse of the shape: To find the shape cut into a plane.
&lt;/p&gt;

&lt;p&gt;
By combining these, it's also possible to subtract one shape from another, for example subtracting a circle from a square.
&lt;/p&gt;

&lt;p&gt;
First, the SDF for a rectangle:
&lt;/p&gt;

&lt;p&gt;
\[
\begin{aligned}
\mathit{sdf\_box}(p) &amp;amp;= \lVert \max(\vec{v}, \vec{0}) \rVert + \min(\max(\vec{v}_x,
\vec{v}_y), 0) \\
\text{where } b &amp;amp;\text{ is bounds of the box},\\
\max(\vec{v}) &amp;amp;\text{ is the element-wise minimum of a vector},\\
\text{abs} &amp;amp;\text{ is the element-wise absolute value of a vector},\\
v &amp;amp;= \text{abs}(p) - \frac{b}{2} \\
\end{aligned}\notag
\]
&lt;/p&gt;

&lt;p&gt;
Or, more intuitively, written in GLSL:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="nf"&gt;sdf_box&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;vec2&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;vec2&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;vec2&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Then the combined equation, including translating the circle for subtraction is:
&lt;/p&gt;

&lt;p&gt;
\[
\mathit{sdf\_eg}(p) = \min(\mathit{sdf\_box}(p), -\mathit{sdf\_circle}(p - 1))
\]
&lt;/p&gt;

&lt;p&gt;
Which gives the following shape: A square with a circle cut out of the top corner.
&lt;/p&gt;

&lt;div class="figure" style="width: auto"&gt;
  &lt;div id="mygraph2" style="max-width: 85vw;"&gt;&lt;/div&gt;
  &lt;p&gt;&lt;span class="figure-number"&gt;Plot 2:&lt;/span&gt;
    A SDF of a square missing a corner. Once again, the shape is bounded by where the function is 0.
  &lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
function sdf_square(x, y) {
    var p = new Vector(x, y);
    var v = p.abs().subtract(new Vector(1,1));

    return v.max(new Vector()).getLength() + Math.min(Math.max(v.x, v.y), 0);
}

function sdf_eg(x, y) {
    return Math.max(
        sdf_square(x, y),
        -sdf_circle_r1(x - 1, y - 1)
    );
}

this.graph = new SDFGraph(document.getElementById('mygraph2'),
                          sdf_eg,
                          5,
                          5,
                          50);
&lt;/script&gt;&lt;p&gt;
It's worth noting SDFs work equally well in 3D as well as 2D. Inigo Quilez has compiled a list of useful &lt;a href="https://iquilezles.org/articles/distfunctions/"&gt;SDFs in 3D&lt;/a&gt; as well as &lt;a href="https://iquilezles.org/articles/distfunctions2d/"&gt;in 2D&lt;/a&gt; which I've constantly used for reference. He's also created some incredible art using SDFs which you can see &lt;a href="https://www.shadertoy.com/user/iq"&gt;on shadertoy&lt;/a&gt;. His work has been a big inspiration for me too, check it out!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org116ad70" class="outline-2"&gt;
&lt;h2 id="org116ad70"&gt;A Slapshot SDF:&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org116ad70"&gt;
&lt;p&gt;
Onto something more useful… A signed distance function for the slapshot rink. This combines a rounded square for the outer perimiter with a capsule for each goal.
&lt;/p&gt;

&lt;div class="figure" style="width: auto"&gt;
  &lt;div id="mygraph3" style="max-width: 85vw;"&gt;&lt;/div&gt;
  &lt;p&gt;&lt;span class="figure-number"&gt;Plot 3:&lt;/span&gt;
    A SDF of the Slapshot: Rebound ice rink.
  &lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;

function sdf_slapshot(x, y) {
    return distanceToEdgeOfRink(new Vector(x, y));
}

this.graph = new SDFGraph(document.getElementById('mygraph3'),
                          sdf_slapshot,
                          110,
                          164,
                          70);
&lt;/script&gt;&lt;p&gt;
The function is most positive near the center of the pitch - these are the points furthest from the edges of the rink. The function is 0 outside the outer perimeter, as well as inside the goals: We don't want bots pathing in there.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org663d646" class="outline-2"&gt;
&lt;h2 id="org663d646"&gt;Gradients, normals and nearest points&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org663d646"&gt;
&lt;p&gt;
As we know, the SDF(p) gives the distance from p to some surface. What's less intuitive is that the derivative of the SDF gives the direction from p to that surface. If you're familiar with gradient descent - that's exactly what's going on here. We can follow the direction of the steepest slope to reach our surface.
&lt;/p&gt;

&lt;p&gt;
In a more mathy term we can write the gradient at a point p as:
\[
\text{grad} f = \nabla f =
\langle \frac{\partial f}{\partial x}, \frac{\partial f}{\partial y} \rangle
\]
Which is essentially saying the gradient is a vector defined by the partial derivitives in each axis.
&lt;/p&gt;

&lt;p&gt;
In some cases it's possible to work these out mathematically, but that's challenging for more complicated examples. Instead, we sample a couple of points nearby and calculate the gradient from those.
&lt;/p&gt;

&lt;p&gt;
\[
\frac{\partial f}{\partial x} \approx \frac{(f(p + k*\vec{x}) - f(p - k*\vec{x}))}{2k}
\]
&lt;/p&gt;

&lt;p&gt;
This is known as the &lt;a href="https://en.wikipedia.org/wiki/Symmetric_derivative"&gt;symmetric derivitive&lt;/a&gt; when taken as the limit as \(k\) tends to \(0\)
&lt;/p&gt;

&lt;p&gt;
Taking a smaller k theoretically gives more accurate results, but in reality you run into numeric precision issues. For Slapshot we sample 4 points that are .5 units in each direction.
&lt;/p&gt;

&lt;p&gt;
A nice property of this is that we can calculate surface normals and tangents for free. The normals are simply the gradient at some point on the surface, and the tangents are orthogonal to that. This is useful for calculating how to approach a puck near the edge, but in other cases it's useful for calculating lighting of objects for example.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1d81a97" class="outline-2"&gt;
&lt;h2 id="org1d81a97"&gt;Nearest points&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1d81a97"&gt;
&lt;p&gt;
What's the nearest point on a surface? It's simply the direction to the nearest point times the distance. We know both of those, so we can plug them in.
&lt;/p&gt;

&lt;p&gt;
\[
  p_{surface} = \nabla f(p) * f(p)
\]
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga8360b3" class="outline-2"&gt;
&lt;h2 id="orga8360b3"&gt;Ray intersection (raymarching)&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orga8360b3"&gt;
&lt;p&gt;
When does a ray first intersect with a SDF surface? One solution is raymarching, which is an itterative process. Given a ray origin and direction, you advance along the ray until you can't anymore (or you've reached a certain level af accuracy). How do you know how far along the ray you can advance? Well, there's one simple observation: The ray can't intersect at a point which is nearer than the nearest point on the surface, and we know the distance to the nearest point - just evaluate the SDF.
&lt;/p&gt;


&lt;div id="org2cf378a" class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/slapshot/sdf_raymarching.png" alt="sdf_raymarching.png" width="500px"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 2: &lt;/span&gt;The calculation at each iteration of raymarching. Credit: Wikipedia.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Start off at a point: The ray origin, then evaluate the SDF. If the resulting distance is smaller than some error value, we're already at an edge. Otherwise, we update that point to be point + distance*ray\&lt;sub&gt;direction&lt;/sub&gt;. It's easy to give the ray some thickness by subtracting the radius from the raw distance, too.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga022884" class="outline-2"&gt;
&lt;h2 id="orga022884"&gt;Puck physics&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orga022884"&gt;
&lt;p&gt;
Along with some simple physics (i.e. restitution and drag) calculations, raymarching is a fast way to calculate where the puck will be in a given amount of time. We use this to calculate where the puck will be some time in the future on each frame. The bots are only given previous predictions as input, which gives them an effective reaction time and makes them play much more human-like!
&lt;/p&gt;

&lt;p&gt;
One slight got'cha is that if the ray origin is very close to the wall, you spend lots of iterations making little headway. We simply say that the puck isn't likely to collide again within a small distance after a collision with the wall, and so begin raymarching a small distance after this has taken place.
&lt;/p&gt;

&lt;p&gt;
This is all extremely fast in code: The bots can each calculate puck predictions for up to 15 seconds into the future on every iteration of the 120hz servers, without breaking a sweat. It would be nice to cache predictions and only recalculate upon collisions, but it's not worth it.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org064454b" class="outline-2"&gt;
&lt;h2 id="org064454b"&gt;Other uses for SDF&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org064454b"&gt;
&lt;p&gt;
Having a quick way to query points is useful for other reasons, too…
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3d875fc" class="outline-3"&gt;
&lt;h3 id="org3d875fc"&gt;Randomness&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org3d875fc"&gt;
&lt;p&gt;
Sometimes it's useful to pick a random point in the pitch… Simple! Just loop until we find one. This succeeds on the first try a vast majority of times.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;public static Vector2 RandomPointInRink(float minDistToEdge=0) {
    Vector2 p;
    do {
	p = new Vector2(
	    Random.Range(-Constants.PITCH_X_EXTENTS2, Constants.PITCH_X_EXTENTS2),
	    Random.Range(-Constants.PITCH_Y_EXTENTS2, Constants.PITCH_Y_EXTENTS2));
    } while (DistanceToEdgeOfRink(p, minDistToEdge) &amp;lt; 0);

    return p;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org06be79a" class="outline-3"&gt;
&lt;h3 id="org06be79a"&gt;Player posturing&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org06be79a"&gt;
&lt;p&gt;
I might write a different post on this, but the bots use these distances to decide where they should stand.
&lt;/p&gt;

&lt;p&gt;
As a quick teaser… This shows 3 members of the red team (red dots, playing downward), and 3 members of the blue team (blue dots, playing upward). The puck (green dot) is being controlled by a member of the blue team. The arrows show, if there was a 4th member of the red team standing somewhere on the pitch, which direction it would be moving in.
&lt;/p&gt;


&lt;div id="org7c7f4c3" class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/slapshot/bots_posturing.png" alt="bots_posturing.png" width="500px"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 3: &lt;/span&gt;How a 4th member of the red team would move from it's current position.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
For example, a member of the red team standing near the blue goal would be rapidly trying to make it's way back up the pitch. That's because the bots really don't 'like' being in front of the puck when the enemy team has possession of it. You can also see between the puck and red goal, there are lots of arrows which converge. This is because bots 'like' standing between the puck and the goal.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5b3d4b1" class="outline-2"&gt;
&lt;h2 id="org5b3d4b1"&gt;Conclusion&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5b3d4b1"&gt;
&lt;p&gt;
This has been part 1 of a series talking about the bots in Slapshot: Rebound. There's lots more novel ideas in there I'd like to write about, so hopefully this was interesting!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description><category>gamedev</category><category>math</category><category>programming</category><guid>https://imois.in/posts/slapshot-sdf-physics/</guid><pubDate>Thu, 17 Nov 2022 18:05:31 GMT</pubDate></item><item><title>(Killer) Sudoku Solver</title><link>https://imois.in/posts/sudoku-solver/</link><dc:creator>Oisin Carroll</dc:creator><description>&lt;div id="outline-container-org3deb950" class="outline-2"&gt;
&lt;h2 id="org3deb950"&gt;(Killer) Sudoku Solver&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3deb950"&gt;
&lt;p&gt;
A solver for killer and/or regular sudokus! It's written in rust and compiled to web assembly. It supports fixed digits and constraints on the sum of different cells.
&lt;/p&gt;

&lt;p&gt;
Enter digits into the grid, or add some sum-rules; a collection of cells which must sum to a given number. As in traditional killer sudoku rules, all cell values in a sum-rule must be unique. For more detailed instructions see below.
&lt;/p&gt;

&lt;div class="sudoku_container"&gt;
    &lt;!--&lt;div&gt;
        &lt;h2&gt;(Killer) Sudoku Solver&lt;/h2&gt;
        &lt;div&gt;
        &lt;p&gt;
        A solver for killer and/or regular sudokus! It's written in rust and compiled to web assembly. It supports fixed digits and constraints on the sum of different cells.
        &lt;/p&gt;
        &lt;p&gt;
        Enter digits into the grid, or add some sum-rules. For more detailed instructions see below.
        &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;--&gt;
    &lt;div&gt;
        &lt;button id="solve_button" type="button"&gt;Solve!&lt;/button&gt;
        &lt;button id="reset_button" type="button"&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
    &lt;table id="sudokutr" class="sudoku_grid"&gt;&lt;/table&gt;
&lt;div class="sumrule_container"&gt;
        &lt;table id="sudokurules" class="sumrule_table"&gt;&lt;tr&gt;
&lt;th&gt;Cell ixs&lt;/th&gt;
&lt;th&gt;Sum To&lt;/th&gt; &lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/table&gt;
&lt;div&gt; &lt;button id="add_rule_button" type="button"&gt;+&lt;/button&gt; &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;script type="module" src="https://imois.in/assets/js/sudoku/sudoku_board.js"&gt;&lt;/script&gt;
&lt;/div&gt;

&lt;div id="outline-container-org74c8c76" class="outline-3"&gt;
&lt;h3 id="org74c8c76"&gt;Fixed digits&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org74c8c76"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;You can enter fixed digits by selecting the cell and entering a digit. You can enter more than one by click+draging or shift+clicking, and enter multiple digits at once.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf858512" class="outline-3"&gt;
&lt;h3 id="orgf858512"&gt;Sum constraints&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf858512"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Each cell has a corresponding index from \(0-81\). Constraints consist of any number of these indices and a sum they should make.&lt;/li&gt;
&lt;li&gt;To create a new constraint: select the desired cells and click the '+' button at the bottom. This will create a new row. You can then modify the sum value itself by clicking on it.&lt;/li&gt;
&lt;li&gt;Constraints can be edited by clicking on the corresponding `Cell ixs` entry, and reselecting squares.&lt;/li&gt;
&lt;li&gt;Unlike some other solvers, constraints can overlap arbitrarily.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf079fef" class="outline-3"&gt;
&lt;h3 id="orgf079fef"&gt;Solving&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf079fef"&gt;
&lt;p&gt;
Finally, when you have a board complete… Hit solve. The first solution found will be displayed, or a warning if no solution is possible.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgde39773" class="outline-3"&gt;
&lt;h3 id="orgde39773"&gt;The solver itself&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgde39773"&gt;
&lt;p&gt;
The solver's been a learning exercise for rust and as such - the code isn't excellent. There are some neat tricks in it though!
&lt;/p&gt;

&lt;p&gt;
It uses bitsets to improve performance, where possibilities for each cell are stored as a single binary number. If [1,3,5] were candidates for a square this is stored as \(000010101\) - where the least significant digit corresponding to 1 being a candidate etc. When a number is placed in a square it can be removed as a candidate from row/column/box efficiently using binary digits.
&lt;/p&gt;

&lt;p&gt;
Sums constraints are calculated and cached in a hashset. If a constraint required us to make 8 in 3 squares there are only two ways to do it: [1,2,5] and [1,3,4]… And is similarly stored as a mask: \(000011111\) - corresponding to all numbers that could make up a solution. This can be used to quickly mask squares. The calculation of these constraints is done quickly and lazily with some dynamic programming tricks - i.e. &lt;a href="https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/"&gt;knapsack&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
When a digit is placed in a cell two things happen - its value is removed as a candidate from row/column/box, then sum constraints containing the cell are updated and the resulting new mask is reapplied to the remaining squares.
&lt;/p&gt;

&lt;p&gt;
If those rules are enough to solve the puzzle - it's extremely fast. It can solve up to 2 million sudokus per second! Otherwise, it must guess a square and backtrack if it reaches a contradiction. It tries to guess the square with the fewest candidates.
&lt;/p&gt;

&lt;p&gt;
It's lack of more complex solving techniques; hidden singles, naked pairs etc. means it struggles to compare with the &lt;a href="https://github.com/t-dillon/tdoku"&gt;fastest solvers of the day&lt;/a&gt;. For comparison it solves ~900/second of the 'puzzles5_forum_hardest' puzzles in the previous link (best=24,001/sec), while averaging a whopping 1456 guesses/puzzle (best=64 guesses). Not too bad for a weekend though… And it may in fact be the fastest killer sudoku solver!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>gamedev</category><category>programming</category><guid>https://imois.in/posts/sudoku-solver/</guid><pubDate>Wed, 16 Jun 2021 22:04:35 GMT</pubDate></item><item><title>Properties of Lights Out: The Game.</title><link>https://imois.in/posts/the-properties-of-lights-out-the-game/</link><dc:creator>Oisin Carroll</dc:creator><description>&lt;div id="outline-container-orgd36d0da" class="outline-2"&gt;
&lt;h2 id="orgd36d0da"&gt;Intro&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgd36d0da"&gt;
&lt;p&gt;
This game was sent to me by Lucy Deacon (Link to be added :P), who found it in &lt;a href="https://play.google.com/store/apps/details?id=name.boyle.chris.sgtpuzzles&amp;amp;hl=en_IE"&gt;Simon Tatham's Puzzles&lt;/a&gt;
under the name 'Flip' around August of 2018. For the few months thereafter
we went down the rabbit-hole on how to solve the game, when it's solvable, and
wrote some fast programs and algorithms to check the properties of some very big
boards. This post contains some of the stuff we managed to work out!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgade11b2" class="outline-2"&gt;
&lt;h2 id="orgade11b2"&gt;The Game&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgade11b2"&gt;
&lt;script src="https://imois.in/assets/js/TouchUtils.js"&gt;&lt;/script&gt;&lt;script src="https://imois.in/assets/js/lights_out/utils.js"&gt;&lt;/script&gt;&lt;script src="https://imois.in/assets/js/lights_out/LightsCanvas.js"&gt;&lt;/script&gt;&lt;script src="https://imois.in/assets/js/lights_out/LightsOut.js"&gt;&lt;/script&gt;&lt;script src="https://imois.in/assets/js/lights_out/LightsOutState.js"&gt;&lt;/script&gt;&lt;p&gt;
&lt;span class="underline"&gt;Lights Out&lt;/span&gt; is a game released by Tiger
Electronics in 1995. You're given a 5x5 grid of lights, some illuminated and
some not, and your task is to turn them all off. The problem is that toggling
each light also toggles all the surrounding lights…
&lt;/p&gt;

&lt;p&gt;
Unfortunately, we didn't know the game had a name, much less a Wikipedia
article, until we'd finished…
&lt;/p&gt;

&lt;p&gt;
I've made a little version of it here… The game works equally well (or does
it!!) on different board sizes. Try to turn all 'lights' off.
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;!-- Arm --&gt;
    &lt;canvas id="lights-out0" class="light_border" width="400" height="300" style="max-width: 85vw;"&gt;
        Your browser doesn't support html5 canvas :c.
    &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Game 1:&lt;/span&gt; The game of Lights-Out in it's original size: 5x5. Click to flip the blue 'lights'! &lt;/p&gt;
&lt;/div&gt;

&lt;script type="text/javascript"&gt;
var g = new LightsOut(document.getElementById('lights-out0'), 5, 5);
g.randomize();
&lt;/script&gt;&lt;p&gt;
The question is… How can you solve it? Is there a way to look at a position
and instantly know how to solve it or even if can be solved at all?
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org68122c1" class="outline-2"&gt;
&lt;h2 id="org68122c1"&gt;Impossible boards?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org68122c1"&gt;
&lt;p&gt;
First of all, not all boards are solvable. A 2x1 board, for example, will never
let you click on only a single tile. If it starts with just one light on,
there's never a way to turn it off… However, is the same true for bigger boards?
&lt;/p&gt;
&lt;div class="figure"&gt;
    &lt;!-- Arm --&gt;
    &lt;canvas id="lights-out2x1" class="light_border" width="400" height="300" style="max-width: 85vw;"&gt;
        Your browser doesn't support html5 canvas :c.
    &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Game 2:&lt;/span&gt; A simple 'parity' case for lights-out. &lt;/p&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
var g = new LightsOut(document.getElementById('lights-out2x1'), 2, 1, maxwidth=300, parity=true);
g.randomize();
&lt;/script&gt;&lt;p&gt;
All other boards in this page are solvable though… So don't worry :P
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org613a37c" class="outline-2"&gt;
&lt;h2 id="org613a37c"&gt;State&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org613a37c"&gt;
&lt;p&gt;
The first thing to notice is that tapping on the same square twice is the same
as not tapping at all, and also that the order you tap the squares doesn't make
a difference. The solution then will never require pressing any square more than
once - and since we don't care about order, we can store just a yes or no for
whether we need to toggle that square.
&lt;/p&gt;

&lt;p&gt;
Here's the same game board (in blue, below), but also the solution for it; the
red squares are the ones to tap to solve the board.
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;!-- Arm --&gt;
    &lt;canvas id="lights-out-state0" class="light_border" width="400" height="300" style="max-width: 85vw;"&gt;
        Your browser doesn't support html5 canvas :c.
    &lt;/canvas&gt;&lt;canvas id="lights-out-game0" class="light_border" width="400" height="300" style="max-width: 85vw;"&gt;
        Your browser doesn't support html5 canvas :c.
    &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Game 3:&lt;/span&gt; The corresponding hidden 'state'/solution (red) for the game board (blue).&lt;/p&gt;
&lt;/div&gt;

&lt;script type="text/javascript"&gt;
var g = new LightsOutState(document.getElementById('lights-out-state0'),
                           document.getElementById('lights-out-game0'),
                           5, 5);
g.randomize();
&lt;/script&gt;&lt;p&gt;
If we could work out the corresponding red board for a new unseen blue one…
We'd be able to solve the game.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9317587" class="outline-2"&gt;
&lt;h2 id="org9317587"&gt;Forward mapping&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9317587"&gt;
&lt;p&gt;
It's not too hard to do the reverse: I.e. take the tapped squares (red) and work out the
corresponding board position. There's also only one mapping from this red
'solution' board to the blue 'game' board: A light will be on if and only if
it's surrounded by an odd number of 'taps'.
&lt;/p&gt;

&lt;p&gt;
In fact, it's possible to represent this as matrix multiplication. If the
board is \(m \times n\), we can write the board-state as a single vector \(\vec{b}\) with \(m*n\)
elements. Each element is 1 if the corresponding light is on and 0 otherwise.
The taps on each square - i.e. the solution for that board can be written similarly as
\(\vec{t}\).
&lt;/p&gt;

&lt;p&gt;
\[ \vec{b} = M\vec{t} \pmod 2 \]
&lt;/p&gt;

&lt;p&gt;
We can also consider the whole problem over a binary field - so that all
arithmetic is carried out modulo 2 anyway.
&lt;/p&gt;

&lt;p&gt;
This matrix \(M\) is a kind of strange 'thick' diagonal matrix. For a 3x3 board it
looks like this:
&lt;/p&gt;

&lt;p&gt;
\[
M_{3\times3} = \begin{Bmatrix}
1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\
0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 \\
\end{Bmatrix}
\]
&lt;/p&gt;

&lt;p&gt;
In order to find a solution for our board, we can find the inverse of this
matrix (if it exists!) and solve the equation.
&lt;/p&gt;

&lt;p&gt;
\[ \vec{t} = M^{-1}\vec{b} \]
&lt;/p&gt;

&lt;p&gt;
If an inverse exists, then for that board there is exactly one solution
corresponding to every board state - and all board states are solvable.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7777b9d" class="outline-2"&gt;
&lt;h2 id="org7777b9d"&gt;Unsolvable boards?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org7777b9d"&gt;
&lt;p&gt;
If there is an unsolvable configuration of the board, i.e. a board state which
has no taps that leaves all the lights off, then it must exist in the null space
of this matrix. A board is completely solvable iff the matrix has no null space.
&lt;/p&gt;

&lt;p&gt;
Hacking out some very bad row-echelon reduction we could graph the nullity of
these matrices for different size boards, this shows which sizes of board are
always solvable, and which have many configurations that make them unsolvable.
&lt;/p&gt;


&lt;div id="org5af1117" class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/lights_out/graph20.png" alt="graph20.png" width="500px"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 1: &lt;/span&gt;What board sizes are solvable? If a boardsize is solvable completely, it's corresponding square in coloured black. A board which is 'as unsolvable' as it's possible to be is white.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
We can see from this that as expected a \(1\times1\) board is always solvable, but
interestingly a \(4\times 4\) is not. There's also interesting patterns forming
already… It looks very regular, and there are lines forming for \(11\times n\)
boards too.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8d16df1" class="outline-2"&gt;
&lt;h2 id="org8d16df1"&gt;Nullity?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8d16df1"&gt;
&lt;p&gt;
It's interesting to mess around with one of the boards with maximum nullity.
Here's a 4x4 board. It's far easier than others because if there is a solution
at all for a position, then there are many.
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;!-- Arm --&gt;
    &lt;canvas id="lights-out4x4" class="light_border" width="400" height="300" style="max-width: 85vw;"&gt;
        Your browser doesn't support html5 canvas :c.
    &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Game 4:&lt;/span&gt; A 4x4 board has the maximum nullity, making it much easier to solve. &lt;/p&gt;
&lt;/div&gt;

&lt;script type="text/javascript"&gt;
var g = new LightsOut(document.getElementById('lights-out4x4'), 4, 4);
g.randomize();
&lt;/script&gt;&lt;p&gt;
Similar to a Rubik's cube, where flipping a single piece makes the puzzle
unsolvable, lights-out boards of many dimensions have similar 'parity' cases.
The nullity of the mapping matrix effectively counts these. For a \(4\times 4\)
board, which has a nullity of 4, there are 4 pieces which are fully determined
by the remaining 12. Also, for every solvable board, there are \(2^4 -1\)
unsolvable ones.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge62ace1" class="outline-2"&gt;
&lt;h2 id="orge62ace1"&gt;'Cascading'&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge62ace1"&gt;
&lt;p&gt;
One (human) way of trying to solve a lights-out puzzle is to always try to
click under any light. If you go through the board row-by-row downwards,
and always click below any 'on' lights, you can take any game state and 'cascade'
all remaining lights into the bottom row.
&lt;/p&gt;

&lt;p&gt;
At this point, you can click a few times in the top row, and repeat the process.
&lt;/p&gt;

&lt;p&gt;
Clicking just
one square in the top row and cascading it to the bottom will cause some of the
squares in the bottom row to flip. This means that each square in the top row corresponds (after
cascade) to some subset of the bottom row being flipped. If we work out what
these correspondences are, we have another way of solving the board.
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;!-- Arm --&gt;
    &lt;canvas id="lights-out-cascade" class="light_border" width="400" height="300" style="max-width: 85vw;"&gt;
        Your browser doesn't support html5 canvas :c.
    &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Game 5:&lt;/span&gt; An animation of cascading. Pick a random square in the top row, then 'cascade' it downwards. Eventually, this will solve the board!&lt;/p&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
var g = new LightsOut(document.getElementById('lights-out-cascade'), 4, 6);

function setupCascade(g, delay) {
    // Add timer to perform cascade...
    window.setInterval(function(){
        // Find highest point under
        var found = false;
        var j = 1, i = 0;
        for (j; j &lt; g.squaresY; j++) {
            for (i=0; i &lt; g.squaresX; i++) {
                // If there's a square above it, we've found where to click.
                if (g.squares[i + (j-1)*g.squaresX] == 1) {
                    found = true;
                    break;
                }
            }
            if (found) break;
        }

        // If we haven't found one, just click anywhere in the top row.
        if (!found) {
            j = 0;
            i = Math.floor(Math.random() * g.squaresX);
        }

        // Click that square
        g.click(i,j);
    }, delay); // 1000ms = 1 sec
}

setupCascade(g, 1000);
&lt;/script&gt;&lt;p&gt;
Since it's possible to always reduce any board (via cascade) to having lights
only in the bottom row, another way to ask if a boardsize is solvable if it's
possible to reach &lt;span class="underline"&gt;any&lt;/span&gt; bottom row configuration by click/cascading. This is
true because cascades commute.
&lt;/p&gt;

&lt;p&gt;
If we construct a matrix from the resulting bottom rows of all possible
click-a-square/cascade ops, it will span all solvable bottom rows.
Then, the boardsize will always be solvable iff that matrix has a nullity of 0.
&lt;/p&gt;

&lt;p&gt;
This is far more efficient than our previous method. Since we can equally
perform cascading left-to-right as well as downwards the matrices we need to
check are only
\(min(m,n)\times min(m,n)\) rather than \(mn \times mn\) as before.
&lt;/p&gt;

&lt;p&gt;
It's interesting that a 4x4 board is always solvable in one try via cascading,
since it's nullity spans the entire bottom row.
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;!-- Arm --&gt;
    &lt;canvas id="lights-out-cascade-big" class="light_border" width="400" height="300" style="max-width: 85vw;"&gt;
        Your browser doesn't support html5 canvas :c.
    &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Game 6:&lt;/span&gt; For fun, here's a very large game cascading. Note the patterns left in the last row. We're interested if it's possible to construct any pattern here by click/cascading any number of times. &lt;/p&gt;
&lt;/div&gt;

&lt;script type="text/javascript"&gt;
var h = new LightsOut(document.getElementById('lights-out-cascade-big'), 20, 20, maxwidth=450);
setupCascade(h, 100);
&lt;/script&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org23e37e9" class="outline-2"&gt;
&lt;h2 id="org23e37e9"&gt;Maximum nullity&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org23e37e9"&gt;
&lt;p&gt;
An interesting result from this is there is a maximum nullity for any board.
&lt;/p&gt;

&lt;p&gt;
Namely, since we can cascade any board into a single row, the nullity
of the mapping between solution and boardstate cannot be larger than \(m\). Also,
we can equally perform the cascade left-to-right, giving an upper bound of \(min(m,n)\).
&lt;/p&gt;

&lt;p&gt;
This can also be proven by looking at the structure of our original mapping matrix \(M\).
&lt;/p&gt;

&lt;p&gt;
\[
M_{3\times3} = \begin{Bmatrix}
1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\
{ \color{red}1 } &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\
0 &amp;amp; { \color{red}1 } &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\
0 &amp;amp; 0 &amp;amp; { \color{red}1 } &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; { \color{red}1 } &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; { \color{red}1 } &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; { \color{red}1 } &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 \\
\end{Bmatrix}
\]
&lt;/p&gt;

&lt;p&gt;
This diagonal (shown in red) will always run from \((0,m)\) to \((n*(m-1), mn)\),
and can be used to construct the first \(n*(m-1)\) columns of a matrix in row-echelon
form. The maximum nullity of this matrix therefore is \(n\). Similarly to before,
the board can be rotated prior to constructing the matrix, and so the maximum
nullity is \(min(m,n)\).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org797fa65" class="outline-2"&gt;
&lt;h2 id="org797fa65"&gt;Bitops&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org797fa65"&gt;
&lt;p&gt;
In order to speed up calculating large boards, we wrote some Very Fast&lt;sup&gt;tm&lt;/sup&gt; c++
matrix code, to perform all binary field arithmetic in parallel with bitops.
The vectors, as well as matrix rows are encoded as several unsigned
integers, each storing 32 binary values. Multiplication can then simply be performed
using xor. Similarly row-echelon reduction and calculation of the rank/nullity
of each matrix can be done extremely quickly.
&lt;/p&gt;

&lt;p&gt;
The cascade operation can also be treated with bit-ops. We take
the current highest non-zero row. This is the row we need to 'click under', so
to speak, and denote it as the top row. We take the row below it (the middle row) and xor
it in-place with the top row. This forms the center of the cross.
&lt;/p&gt;

&lt;p&gt;
Next, we can xor the middle row once again with the top row bitshifted once
left, and once right (being careful to handle overlaps), forming the left/right
arms of the cross. We can then xor the row further below (the bottom
row) in-place with the top row, forming the base of the cross. Finally the top
row can be set to 0s, which is effectively the top of the cross.
&lt;/p&gt;

&lt;p&gt;
This allows us to perform up to 32 'clicks' at once, in very few bit operations.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org19ad69d" class="outline-2"&gt;
&lt;h2 id="org19ad69d"&gt;Low memory cascade&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org19ad69d"&gt;
&lt;p&gt;
Although this cascade is fast, it requires a lot of memory. In order to generate
the matrix for, e.g. a \(4000 \times 4000\) board, it requires 4000 boards, or the
same board to be used 4000 times. This is getting very large!
&lt;/p&gt;

&lt;p&gt;
If we consider click-cascading only on an empty board, we only ever have 3 rows with
non-zero entries at a time. We can perform the operation only with 3 rows,
shuffling them around on each iteration.
&lt;/p&gt;

&lt;p&gt;
We can do better though. With the bottom row starting empty, it really just
becomes set equal to the top row. This means we can store just 2 rows, and
treat them as top/middle. We can perform each cascade iteration with 3 xors and
two bitshifts for up to 32 clicks. It's also close in memory which should reduce
cache misses.
&lt;/p&gt;

&lt;p&gt;
All in all, this sped up our program by from taking almost
20 hours to calculate all boards up to \(512\times 512\) to just 12 seconds. It's
6000 times faster, without parallelization. The speedup is even more significant
vs the pre-cascading programs and our initial python/numpy code too.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdd99b69" class="outline-2"&gt;
&lt;h2 id="orgdd99b69"&gt;Lots of boards&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgdd99b69"&gt;
&lt;p&gt;
In order to calculate nullity for a few million boards… We could compute
the matrices for all boards of a certain width simultaneously. Cascade once,
grab the new bottom row for each board, copy it into a matrix, reduce it in-place
and calculate nullity, and discard it. We can then iterate to calculate the
nullity of a board that is \((m+1)\times n\). To parallelize, each core just takes a
width of board and calculates the nullity of all boards of that width up to a
maximum. This took a few days to run on a HPC cluster, even with all of our
optimizations.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org47e3f26" class="outline-2"&gt;
&lt;h2 id="org47e3f26"&gt;Results!!&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org47e3f26"&gt;
&lt;p&gt;
The resulting images for different sizes.
&lt;/p&gt;


&lt;div id="org119754d" class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/lights_out/graph128.png" alt="graph128.png" width="500px"&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div id="org946659e" class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/lights_out/graph512.png" alt="graph512.png" width="500px"&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div id="org5c19a0b" class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/lights_out/graph4096.png" alt="graph4096.png" width="500px"&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Here we can see the patterns that continue even for very large boards. In the
512x512 image, there's a faint grid forming at near powers of 2: 127 and 255.
Above it, there's a similar line around 63. The largest size: 4096 requires
zooming for the 'constellations' to be even visible, but they're there, with
several big spots also scattered around.
&lt;/p&gt;

&lt;p&gt;
It's interesting that, as you move further 'out', the boards are relatively more
solvable. The intuition is that, for a board to have a very high nullity, many
it's click/cascade vectors must align. This becomes increasingly more unlikely to
happen as these vectors increase in size and number.
&lt;/p&gt;

&lt;p&gt;
There're very few large boards which loose all dimensions. These are the only
ones larger than 1024*1024 (not including rotations).
&lt;/p&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;
&lt;colgroup&gt;
&lt;col class="org-right"&gt;
&lt;col class="org-right"&gt;
&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th scope="col" class="org-right"&gt;height&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;width&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;percentage nullity&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;1023&lt;/td&gt;
&lt;td class="org-right"&gt;1535&lt;/td&gt;
&lt;td class="org-right"&gt;1.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;1023&lt;/td&gt;
&lt;td class="org-right"&gt;3071&lt;/td&gt;
&lt;td class="org-right"&gt;1.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;1279&lt;/td&gt;
&lt;td class="org-right"&gt;3839&lt;/td&gt;
&lt;td class="org-right"&gt;1.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;1791&lt;/td&gt;
&lt;td class="org-right"&gt;2303&lt;/td&gt;
&lt;td class="org-right"&gt;1.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;2047&lt;/td&gt;
&lt;td class="org-right"&gt;3071&lt;/td&gt;
&lt;td class="org-right"&gt;1.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;1407&lt;/td&gt;
&lt;td class="org-right"&gt;3967&lt;/td&gt;
&lt;td class="org-right"&gt;0.9097370291400142&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;1535&lt;/td&gt;
&lt;td class="org-right"&gt;3071&lt;/td&gt;
&lt;td class="org-right"&gt;0.9993485342019544&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
These are all surprisingly structured! Often near 2&lt;sup&gt;n&lt;/sup&gt;-1 or 3*2&lt;sup&gt;n&lt;/sup&gt;-1 (i.e. 3071).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org2d7957e" class="outline-2"&gt;
&lt;h2 id="org2d7957e"&gt;Other…&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org2d7957e"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orga882290" class="outline-3"&gt;
&lt;h3 id="orga882290"&gt;Looping patterns?&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga882290"&gt;
&lt;p&gt;
Since a cascade operation can be written as a matrix multiplication (if the
board has width \(m\), the resulting cascade matrix is \(2m\times 2m\)), we can
consider powers of it instead of repeatedly cascading.
&lt;/p&gt;

&lt;p&gt;
The question becomes, what power of this matrix results in the identity matrix
(or the same cascade matrix again)? This would mean the nullity of boards of a
certain width would form a long repeating pattern based on their height.
&lt;/p&gt;

&lt;p&gt;
The period of small cascade matrices; less than 40, are all about/below 8000-16000,
but it blows up from there… The period of the cascade over a board of width 40
is over one million iterations.
&lt;/p&gt;

&lt;p&gt;
Funnily, we both came up with this idea coincidentally within a few minutes of each other.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb89c9be" class="outline-3"&gt;
&lt;h3 id="orgb89c9be"&gt;Sequences&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb89c9be"&gt;
&lt;p&gt;
Some board widths are surprisingly solvable/ unsolvable. We found boards of size
(\(10 \times 31n-1\)) are all unsolvable (nullity of 10) to as high as we could
calculate at the time.
&lt;/p&gt;

&lt;p&gt;
Several other widths are surprisingly solvable, 10 (other than above), 81, and many more.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7e96fbc" class="outline-3"&gt;
&lt;h3 id="org7e96fbc"&gt;OEIS&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org7e96fbc"&gt;
&lt;p&gt;
The Online Encyclopedia of Integer Sequences is a searchable database
containing, well, integer sequences. After finishing up, we tried searching it
for our sequence. It turns out square boards have their own entry &lt;a href="https://oeis.org/A093614"&gt;here!&lt;/a&gt; This was
the first time we knew the game by it's proper name, and found the game's
relation to other areas of cellular automata.
&lt;/p&gt;

&lt;p&gt;
We'd generated almost twice as far as the furthest though! The highest term in
the OEIS sequence is 2363, while ours is ~4100.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1366f80" class="outline-2"&gt;
&lt;h2 id="org1366f80"&gt;Conclusion&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1366f80"&gt;
&lt;p&gt;
I think we both agree we haven't completely figured out as much as we'd like…
The patterns are still somewhat a mystery, even if we've found some logic in
them! It's one to revisit for sure :P.
&lt;/p&gt;

&lt;p&gt;
As always, feel free to dig through the source code for this page either here or
on &lt;a href="https://github.com/oisincar/imois.in/tree/master/assets/js/lights_out"&gt;my Github for the site&lt;/a&gt;! It's written in pure javascript/html canvas (apart from the english,
that's written in english…).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description><category>gamedev</category><category>math</category><category>programming</category><guid>https://imois.in/posts/the-properties-of-lights-out-the-game/</guid><pubDate>Thu, 19 Dec 2019 16:59:29 GMT</pubDate></item><item><title>Procedural Animation 3: Gradient Descent</title><link>https://imois.in/posts/procedural-animation-3-gradient-descent/</link><dc:creator>Oisin Carroll</dc:creator><description>&lt;div id="outline-container-orgfe447b6" class="outline-2"&gt;
&lt;h2 id="orgfe447b6"&gt;Intro&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgfe447b6"&gt;
&lt;script type="text/javascript" src="https://unpkg.com/vis-graph3d@latest/dist/vis-graph3d.min.js"&gt;&lt;/script&gt;&lt;script src="https://imois.in/assets/js/TouchUtils.js"&gt;&lt;/script&gt;&lt;script src="https://imois.in/assets/js/procedural_animation/Global.js"&gt;&lt;/script&gt;&lt;script src="https://imois.in/assets/js/procedural_animation/Arm.js"&gt;&lt;/script&gt;&lt;script src="https://imois.in/assets/js/procedural_animation/ArmCanvas.js"&gt;&lt;/script&gt;&lt;script src="https://imois.in/assets/js/procedural_animation/Graph.js"&gt;&lt;/script&gt;&lt;script src="https://imois.in/assets/js/procedural_animation/GradientDescent2Link.js"&gt;&lt;/script&gt;&lt;script src="https://imois.in/assets/js/procedural_animation/TwoLinkArmAndGraph.js"&gt;&lt;/script&gt;&lt;p&gt;
In this third and final section, we'll cover how to solve harder problems that don't
necessarily have a single solution, or ones that have solutions that can't be
written as an equation of known variables.
&lt;/p&gt;

&lt;p&gt;
If you haven't read &lt;a href="https://imois.in/posts/procedural-animation-1-state-machines/"&gt;Part 1&lt;/a&gt;, we covered some simple state machines and some
general ideas on how I try to approach these kind of problems.
&lt;/p&gt;

&lt;p&gt;
You might also want to check out &lt;a href="https://imois.in/posts/procedural-animation-2-functions"&gt;Part 2&lt;/a&gt;, where we went over how to build up more
complex movement by combining functions of state.
&lt;/p&gt;

&lt;p&gt;
And finally, all of the (interactive!) animations here are running in javascript canvas, so you can open the
source code in the inspector or find it on &lt;a href="https://github.com/oisincar/imois.in/tree/src/files/assets/js/procedural_animation"&gt;my github for the site!&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org28cecbf" class="outline-2"&gt;
&lt;h2 id="org28cecbf"&gt;What we'll make!&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org28cecbf"&gt;
&lt;p&gt;
These tenticles/ arms/ vines might make a fun enemy or background in a game, but
also demonstrate an idea that can be used to solve all kinds of problems! The
same idea (gradient descent) is the backbone of a huge amount of modern AI -
used to improve Google's results, autonomous cars, and more… And all you
need to understand it is a basic knowledge of derivatives.
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;!-- Arm --&gt;
    &lt;canvas id="intro-demo-arms" class="light_border" width="400" height="300" style="max-width: 85vw;"&gt;
        Your browser doesn't support html5 canvas :c.
    &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Anim 1:&lt;/span&gt; Reaching arms with 20 and 100 segments. Click &amp;amp; Drag to move the ball!&lt;/p&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
class GradientDescentLongChain {

    constructor(id) {
        var self = this;

        var armC = new ArmCanvas(
            document.getElementById(id),
            function(){self.finished = false;});

        this.arm = new Arm(20, 300, -250);
        this.arm2 = new Arm(100, 100, -50);

        armC.addArm(this.arm);
        armC.addArm(this.arm2);

        // Double arm length
        this.arm._lengths = this.arm._lengths.map(function(x) { return x*1.7; });
        this.arm2._angles = this.arm2._angles.map(function(x) { return 0; });

        var doUpdate = true;
        if (doUpdate)
            setInterval(function() { self.update(); }, self.interval);
    }

    improve(arm) {
        // var grads = this.arm.calculateCurrentGradients();
        var grads = arm.calculateCurrentGradientsSq();

        // Update arm angles!
        for (var i = 0; i &lt; grads.length; i++) {
            arm.changeAngle(i, -grads[i]*0.00001);
        }

        // If we're now close enough, don't update til we have to again.
        if (arm.getCurrentError() &lt; 0.05) {
            return true;
        }
        return false;
    }

    update() {
        // Only do stuff if we're not already at the target.
        if (!this.finished) {
            // Finished if both arms are finished
            var a1 = this.improve(this.arm);
            var a2 = this.improve(this.arm2);
            this.finished = a1 &amp;&amp; a2;
        }
    }
}

var b = new GradientDescentLongChain('intro-demo-arms');
&lt;/script&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org409bc71" class="outline-2"&gt;
&lt;h2 id="org409bc71"&gt;The problem: Kinematics&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org409bc71"&gt;
&lt;p&gt;
Generally, (and according to google) kinematics is a branch of mechanics that
deals with the features or properties of the motion of an object. It's often
referred to as the "Geometry of Motion". For character animation, we usually
deal with Kinematics of Simple Chains - or limbs…
&lt;/p&gt;

&lt;p&gt;
For a given arm, &lt;b&gt;Forward Kinematics&lt;/b&gt; is working out where the hand (or end) is
in space given the angles between the shoulder, and upper and lower arms. The
opposite of this, called &lt;b&gt;Inverse Kinematics&lt;/b&gt; (IK), is where you have a fixed
target point and instead want to choose the same angles so the hand is as close
to it as possible.
&lt;/p&gt;

&lt;dl class="org-dl"&gt;
&lt;dt&gt;&lt;b&gt;Forward Kinematics:&lt;/b&gt;&lt;/dt&gt;
&lt;dd&gt;Your upper arm is at \(\alpha\) to your torso, and your
upper arm is \(\beta\) to your lower arm, where is your hand?&lt;/dd&gt;

&lt;dt&gt;&lt;b&gt;Inverse Kinematics:&lt;/b&gt;&lt;/dt&gt;
&lt;dd&gt;You want to reach for a ball in-front of you, what
angles should you have at your shoulder and elbow?&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;
We're going to look at the second one. Inverse Kinematics are used for all kinds
of character animation, robotics, and predicting people's location in VR. It'd
be pretty useful to have a way to solve it!
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;span class="align_all"&gt;
        &lt;div&gt;
            &lt;!-- Arm --&gt;
            &lt;canvas id="twolinkarmandgraph_smp" class="light_border" width="400" height="300" style="max-width: 85vw;"&gt;
                Your browser doesn't support html5 canvas :c.
            &lt;/canvas&gt;&lt;!-- Sliders --&gt;&lt;span class="slider_row"&gt;
                &lt;span class="slider_label"&gt;Shoulder Angle (α)&lt;/span&gt;
                &lt;span id="ang1_smp" class="flat-slider"&gt;&lt;/span&gt;
                &lt;span type="text" id="ang1val_smp" class="slider_text"&gt;&lt;/span&gt;
            &lt;/span&gt;

            &lt;span class="slider_row"&gt;
                &lt;span class="slider_label"&gt;Elbow Angle (β)&lt;/span&gt;
                &lt;span id="ang2_smp" class="flat-slider"&gt;&lt;/span&gt;
                &lt;span type="text" id="ang2val_smp" class="slider_text"&gt;&lt;/span&gt;
            &lt;/span&gt;
        &lt;/div&gt;
    &lt;/span&gt;
    &lt;p&gt;&lt;span class="figure-number"&gt;Anim 1:&lt;/span&gt; The problem: Trying to reach for the ball by changing the angles of both joints. How can we find these angles?&lt;/p&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
{
    function UpdateGraph() {}
    // Create an arm in that space
    var armC = new ArmCanvas(document.getElementById('twolinkarmandgraph_smp'), UpdateGraph);
    armC.targetX = 27;
    armC.targetY = 13;

    var arm = new Arm(2);
    armC.addArm(arm);

    this.arm = arm;

    // slider
    $("#ang1_smp").slider({
        min: 0,
        max: 180,
        values: [arm.getAngle(0)],
        slide: function(event, ui) {
            $("#ang1val_smp").text(ui.values[0] + "°")
            arm.setAngle(0, ui.values[0]);
        },
    });
    $("#ang1val_smp").text(arm.getAngle(0) + "°");

    $("#ang2_smp").slider({
        min: -160,
        max: 160,
        values: [arm.getAngle(1)],
        slide: function(event, ui) {
            $("#ang2val_smp").text(ui.values[0] + "°");
            arm.setAngle(1, ui.values[0]);
        }
    });
    $("#ang2val_smp").text(arm.getAngle(1) + "°");
}
&lt;/script&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0e2e9fb" class="outline-2"&gt;
&lt;h2 id="org0e2e9fb"&gt;Simple arms in 2d&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org0e2e9fb"&gt;
&lt;p&gt;
For the 2D case, and when there are only two joints in the arm, there are (usually) two solutions - an
'elbows up' position, and an 'elbows down' one.
&lt;/p&gt;

&lt;p&gt;
Of course, there are cases where there is no solution. If the ball is out of
reach, for example.
&lt;/p&gt;

&lt;p&gt;
It's possible to work out these two angles with coordinate geometry or a bit of
trig, as long as you have the lengths of both arm segments and the target
location. However, as there are a million other gamedev sites, robotics courses,
and random medium posts, I won't explain it here again. It is a fun problem
though - I'd recommend giving it a go!
&lt;/p&gt;

&lt;p&gt;
It's also worth noting problems and limbs in 3D can be solved using the same 2D algorithm/equation
with one trick: An 'elbow target'. We add a point that, given the choice, the
elbow will be as near to as possible. This (interestingly) causes all 5 points: Shoulder, Elbow,
Hand, Hand Target, and Elbow Target to all lie in the same plane. We can take
the plane defined by the fixed points: Shoulder, Hand Target, and Elbow Target
and solve the problem in 2d on that plane. This is how a lot of kinematics in
games is done.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd806d27" class="outline-2"&gt;
&lt;h2 id="orgd806d27"&gt;Harder problems.. I.e. Arms with more joints..?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgd806d27"&gt;
&lt;p&gt;
It's not possible to solve harder problems using the same idea however, if you
add an extra segment to the arm there suddenly isn't a way to find solutions
(mostly because there are now likely infinite solutions…).
&lt;/p&gt;

&lt;p&gt;
This is what I wanted to write about… How can you find approximate or fast
solutions to a problem that's much harder to solve exactly, or find 'organic'
solutions to some problem that has a lot of possible solutions.
&lt;/p&gt;

&lt;p&gt;
Instead of trying to find a solution instantly, we take the current position of
the arm and figure out how to improve it slightly. The solution is then
calculated iteratively, looping over and over either until we're not getting
any closer or we're within some distance.
&lt;/p&gt;

&lt;p&gt;
Because we're only 3 dimensional creatures… The solution is easiest to
describe for arms with 2 joints… But the maths works for any number of joints.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org622cd65" class="outline-2"&gt;
&lt;h2 id="org622cd65"&gt;Forward Kinematics&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org622cd65"&gt;
&lt;p&gt;
First, we need to work out where the end of our arm is… We write the angle at
the shoulder as \(\alpha\), and at the elbow as \(\beta\). The length of the upper
arm is \(l1\), and forearm is \(l2\). I take the shoulder to be at \((0,0)\)
&lt;/p&gt;

&lt;p&gt;
To do this, we can split it into 2 parts. The position of the elbow will be at:
&lt;/p&gt;

\begin{align*}
Elbow_x &amp;amp; = l1 * sin(\alpha) \\
Elbow_y &amp;amp; = l1 * cos(\alpha)
\end{align*}

&lt;p&gt;
Then, similarly, we can work out the position of the hand relative to the elbow.
This is a little harder to see, but we can take the angle of the arm relative to
the ground (\(\alpha + \beta\)) and use the same trig formula.
&lt;/p&gt;

\begin{align*}
Hand_x - Elbow_x &amp;amp; = l2 * sin(\alpha + \beta) \\
Hand_y - Elbow_y &amp;amp; = l2 * cos(\alpha + \beta)
\end{align*}

&lt;p&gt;
Then the position of the hand is simply the sum.
&lt;/p&gt;

\begin{align*}
Hand_x &amp;amp; = l1 * sin(\alpha) + l2 * sin(\beta - \alpha) \\
Hand_y &amp;amp; = l1 * cos(\alpha) + l2 * cos(\beta - \alpha)
\end{align*}
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org747d414" class="outline-2"&gt;
&lt;h2 id="org747d414"&gt;Distance function&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org747d414"&gt;
&lt;p&gt;
In order to perform gradient descent, we need a formula for the error we're
trying to reduce. This is the distance from our hand to our target. Ideally, we
want this distance to be 0, which'd mean our hand is exactly on the target.
&lt;/p&gt;

&lt;p&gt;
The distance in x and y can be written from the above. Here \(|x|\) means the
absolute value of x, or the non-negative value of x.
&lt;/p&gt;

\begin{align*}
Dist_x &amp;amp; = | Target_x - (l1 * sin(\alpha) + l2 * sin(\alpha + \beta)) | \\
Dist_y &amp;amp; = | Target_y - (l1 * cos(\alpha) + l2 * cos(\alpha + \beta)) |
\end{align*}

&lt;p&gt;
Then using pythagoras the distance is:
&lt;/p&gt;

\begin{align*}
Dist = \sqrt{Dist_x^2 - Dist_y^2}
\end{align*}

&lt;p&gt;
We can look at this distance for any value of \(\alpha\) and \(\beta\). If we plot
\(\alpha\) and \(\beta\) on the x and y coordinates of a graph, and the
corresponding distance the arm is from the target the z (vertical) axis, we can
view the distance as a shape.
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;span class="align_all"&gt;
        &lt;div&gt;
            &lt;!-- Arm --&gt;
            &lt;canvas id="twolinkarmandgraph" class="light_border" width="600" height="300" style="max-width: 85vw;"&gt;
                Your browser doesn't support html5 canvas :c.
            &lt;/canvas&gt;&lt;!-- Sliders --&gt;&lt;span class="slider_row"&gt;
                &lt;span class="slider_label"&gt;Shoulder Angle (α)&lt;/span&gt;
                &lt;span id="ang1" class="flat-slider"&gt;&lt;/span&gt;
                &lt;span type="text" id="ang1val" class="slider_text"&gt;&lt;/span&gt;
            &lt;/span&gt;

            &lt;span class="slider_row"&gt;
                &lt;span class="slider_label"&gt;Elbow Angle (β)&lt;/span&gt;
                &lt;span id="ang2" class="flat-slider"&gt;&lt;/span&gt;
                &lt;span type="text" id="ang2val" class="slider_text"&gt;&lt;/span&gt;
            &lt;/span&gt;

            &lt;span class="slider_row"&gt;
                &lt;span class="slider_label"&gt;Upper Arm Len&lt;/span&gt;
                &lt;span id="l1" class="flat-slider"&gt;&lt;/span&gt;
                &lt;span type="text" id="l1val" class="slider_text"&gt;&lt;/span&gt;
            &lt;/span&gt;

            &lt;span class="slider_row"&gt;
                &lt;span class="slider_label"&gt;Forearm Len&lt;/span&gt;
                &lt;span id="l2" class="flat-slider"&gt;&lt;/span&gt;
                &lt;span type="text" id="l2val" class="slider_text"&gt;&lt;/span&gt;
            &lt;/span&gt;

        &lt;/div&gt;
        &lt;div id="mygraph" style="max-width: 85vw;"&gt;&lt;/div&gt;
    &lt;/span&gt;
    &lt;script&gt; var a = new TwoLinkArmAndGraph(); &lt;/script&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Anim 2:&lt;/span&gt; The distance function for any of the shoulder and elbow angles.
    On the graph: Click to pan, scroll wheel to zoom, and mouse over to see the distance/angles at any point. Try messing around
    with the angles and arm lengths, or move the target ball!&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Each point on the surface corresponds to some shoulder and elbow angles, and the
height (or colour) there corresponds to the distance those angles put the hand
from the target. As you change the angles of the arms, you can see the graph
translate - the center of it shows the current elbow and shoulder angles.
&lt;/p&gt;

&lt;p&gt;
Try tweaking lengths, then read the lowest/highest point from the graph… Then change
the arm's angles to those and see what it looks like.
&lt;/p&gt;

&lt;p&gt;
There's often two low points in the graph - which correspond to the two best
 solutions. Moving the ball far away gives only one low point - meaning there's
 only one best solution; when the arm is pointing towards it.
 There's also usually one worst solution (the reddest/ highest point), which
 is where the arm is pointing away from the ball.
&lt;/p&gt;

&lt;p&gt;
Our goal will be effectively to try and find the lowest point on this surface -
the angles there will bring our arm closest to our target ball.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf3b5428" class="outline-2"&gt;
&lt;h2 id="orgf3b5428"&gt;Gradient Descent&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf3b5428"&gt;
&lt;p&gt;
We can use the derivative of this distance function to improve our errors.
First, write the distance corresponding to \(\alpha\) and \(\beta\) as \(Dist(\alpha, \beta)\).
&lt;/p&gt;

&lt;p&gt;
Then we can consider the partial derivative with respect to the angles.
&lt;/p&gt;

\begin{align*}
\frac{\partial Dist}{\partial \alpha}
\end{align*}

&lt;p&gt;
This works out to a single value, and can be read/ thought of as 'how does the
distance to the target change when I change \(\alpha\) by a very small amount'.
&lt;/p&gt;

&lt;p&gt;
For example if \(\frac{\partial Dist}{\partial \alpha}\) is positive, then
increasing \(\alpha\) will increase the distance. Decreasing \(\alpha\) then brings the
hand towards the target. If the derivative is negative, we
should instead increase \(\alpha\) by a small amount to improve our hand position.
This can be written as:
&lt;/p&gt;

\begin{align*}
\alpha := \alpha - k * \frac{\partial Dist}{\partial \alpha}
\end{align*}

&lt;p&gt;
Here k is a small value, in the animations I have it set to 0.0001. This means
each update loop we update alpha to move the hand a little closer.
&lt;/p&gt;

&lt;p&gt;
The maths is exactly the same for the elbow position:
&lt;/p&gt;

\begin{align*}
\beta := \beta - k* \frac{\partial Dist}{\partial \beta}
\end{align*}

&lt;p&gt;
And for any number of limbs.
&lt;/p&gt;

&lt;p&gt;
This method of improving iteratively is called 'gradient descent'. This can be visualized from Anim 2; we're essentially standing on a point on the surface, then finding the direction of steepest descent and moving a short distance.
Repeating this process will, in many problems (including this one), always get us to a solution if it exists.
&lt;/p&gt;

&lt;p&gt;
Proving that this method finds the direction of steepest descent, or that this problem is convex and so will always find a possible solution is left as an exercise to the reader :)
&lt;/p&gt;

&lt;p&gt;
The demos just perform this update once per frame, but it's easy to completely solve the system by running for more iterations.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1fe1866" class="outline-2"&gt;
&lt;h2 id="org1fe1866"&gt;Implementation &amp;amp; Extras&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1fe1866"&gt;
&lt;p&gt;
It might help to look through the source code for the animations (embedded into
this page), or available &lt;a href="https://github.com/oisincar/imois.in/blob/master/assets/js/procedural_animation/Arm.js"&gt;here on Github&lt;/a&gt;. You're free to lift this for anything,
the code's CC0!
&lt;/p&gt;

&lt;p&gt;
Here's a bonus of what happens when you accidentally make 3 arms compete for who
renders at the same time…
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;!-- Arm --&gt;
    &lt;canvas id="twolinkgrad_arm_canvas_broken" class="light_border" width="500" height="400" style="max-width: 85vw;"&gt;
        Your browser doesn't support html5 canvas :c.
    &lt;/canvas&gt;&lt;script&gt;
      new GradientDescent2Link('twolinkgrad_arm_canvas_broken', 2);
      new GradientDescent2Link('twolinkgrad_arm_canvas_broken', 4);
      new GradientDescent2Link('twolinkgrad_arm_canvas_broken', 15);
    &lt;/script&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Anim 3:&lt;/span&gt; Glitchy movement, could be a neat effect for a Stranger Things monster..?&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Anyway, I hope this helped! Gradient descent is a very powerful tool for solving
any kind of problem if you're able to express it in a certain way. For more
procedural animation stuff, you might be interested in &lt;a href="https://imois.in/posts/procedural-animation-1-state-machines/"&gt;Part 1&lt;/a&gt; where I looked at
some core ideas and a light animation, or &lt;a href="https://imois.in/posts/procedural-animation-2-functions"&gt;Part 2&lt;/a&gt; with some more fancy function
ideas and shapes.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description><category>animation</category><category>gamedev</category><category>math</category><category>programming</category><guid>https://imois.in/posts/procedural-animation-3-gradient-descent/</guid><pubDate>Tue, 26 Nov 2019 00:22:20 GMT</pubDate></item><item><title>Procedural Animation 2: Functions</title><link>https://imois.in/posts/procedural-animation-2-functions/</link><dc:creator>Oisin Carroll</dc:creator><description>&lt;div id="outline-container-org35b2581" class="outline-2"&gt;
&lt;h2 id="org35b2581"&gt;Intro&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org35b2581"&gt;
&lt;p&gt;
In this second section, I wanted to talk about functions… And how to take simple
movements and build more complex animations from them. Be warned: &lt;i&gt;Here be graphs&lt;/i&gt;.
&lt;/p&gt;

&lt;p&gt;
We'll be using the idea of &lt;b&gt;State&lt;/b&gt;, &lt;b&gt;Update&lt;/b&gt;, &lt;b&gt;Apply&lt;/b&gt; from &lt;a href="https://imois.in/posts/procedural-animation-1-state-machines/"&gt;Part 1&lt;/a&gt; here too. If
you haven't read that, you might want to start there!
&lt;/p&gt;

&lt;p&gt;
And finally, all of the animations are running in javascript canvas, so you can open the
source code in the inspector or find it on &lt;a href="https://github.com/oisincar/imois.in/tree/src/files/assets/js/procedural_animation"&gt;my github for the site!&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb30aa57" class="outline-2"&gt;
&lt;h2 id="orgb30aa57"&gt;Bouncing ball&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb30aa57"&gt;
&lt;p&gt;
How to make this?
&lt;/p&gt;

&lt;script src="https://imois.in/assets/js/procedural_animation/BouncingBalls.js"&gt;&lt;/script&gt;&lt;div class="figure"&gt;
    &lt;canvas id="balls0" class="light_border" width="400" height="300"&gt; Your browser sucks :c. &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Anim 1:&lt;/span&gt; Moving the ball&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt; new BouncingBalls('balls0', 0, 1); &lt;/script&gt;&lt;p&gt;
For the &lt;b&gt;State&lt;/b&gt;, we can just have a single number that varies from 0 to 1:
The percentage through the animation we are so far.
&lt;/p&gt;

&lt;p&gt;
This means our &lt;b&gt;Update&lt;/b&gt; can turn the elapsed time into a percentage value and
add it to the &lt;b&gt;State&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
And our &lt;b&gt;Apply&lt;/b&gt; can move the ball based on the state variables, and draw it. For
this, we only need to change the y coordinate:
&lt;/p&gt;

&lt;p&gt;
y = state*k, where k a scaling value for how far the ball moves.
&lt;/p&gt;


&lt;p&gt;
In code this looks like:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// CONFIG:&lt;/span&gt;
&lt;span class="c1"&gt;// 'scale in time', length of animation&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;_duration&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;5.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// 'scale in space', distance ball moves&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;_dist&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;40.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// 'offset in space'&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Vector2&lt;/span&gt; &lt;span class="n"&gt;_offset&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Vector2&lt;/span&gt;&lt;span class="p"&gt;(..);&lt;/span&gt;

&lt;span class="c1"&gt;// STATE:&lt;/span&gt;
&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;dt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// dt is the change in time.&lt;/span&gt;
    &lt;span class="c1"&gt;// UPDATE state:&lt;/span&gt;
    &lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;dt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;_duration&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// 1_|&lt;/span&gt;
    &lt;span class="c1"&gt;//   | /| /| /| /|....&lt;/span&gt;
    &lt;span class="c1"&gt;// 0_|/ |/ |/ |/ |&lt;/span&gt;

    &lt;span class="c1"&gt;// APPLY&lt;/span&gt;
    &lt;span class="n"&gt;ball&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_offset&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_dist&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The update line can be a bit confusing, but might make more sense when split up a bit more.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;dt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;_duration&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Equilivent to (all of):&lt;/span&gt;
&lt;span class="c1"&gt;// The change in how far we are through the animation.&lt;/span&gt;
&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;dPerc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dt&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;_duration&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// Added to _animationPerc&lt;/span&gt;
&lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;dPerc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// And wrap back to 0 if we're &amp;gt; 1;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
We're working out how much further we are through the animation (```dPerc```)
which is our change it time divided by the duration of the animation. Say our
animation is 2 seconds long, and 1 second just elapsed… We're now half-way
further through than before.
&lt;/p&gt;

&lt;p&gt;
It might be helpful to think of the shape this variable (or all variables) make over time. A
lot of these animations can be thought of as the &lt;b&gt;Apply&lt;/b&gt; function reshaping the &lt;b&gt;State&lt;/b&gt; variables.
&lt;/p&gt;



&lt;div id="org47fc836" class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/procedural_anim/animation_perc.png" alt="animation_perc.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 1: &lt;/span&gt;The shape of _animationPerc over time, where d is the duration of the animation, makes a sawtooth shape.&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;
In this example, our &lt;b&gt;Apply&lt;/b&gt; function just scales the &lt;b&gt;State&lt;/b&gt; by _dist. This is
then the y offset of the ball for that frame, as shown in the animation above.
&lt;/p&gt;


&lt;div id="orgc8fefb8" class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/procedural_anim/animation_apply1.png" alt="animation_apply1.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 2: &lt;/span&gt;Here, the input &lt;b&gt;State&lt;/b&gt; (Blue), is scaled to give the ball's positional offset by the &lt;b&gt;Apply&lt;/b&gt; function (Orange).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org04cc7b9" class="outline-2"&gt;
&lt;h2 id="org04cc7b9"&gt;Different Applications (heh)&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org04cc7b9"&gt;
&lt;p&gt;
By just changing the &lt;b&gt;Apply&lt;/b&gt; function here, we can get a variety of different
movements. We can think of these movements as transformations of the origional
&lt;b&gt;State&lt;/b&gt; graph, since this is the only input.
&lt;/p&gt;

&lt;p&gt;
First lets move the ball up and down in wave like this…
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;canvas id="balls1" class="light_border" width="400" height="300"&gt; Your browser sucks :c. &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Anim 2:&lt;/span&gt; Wavey ball&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt; new BouncingBalls('balls1', 1, 1); &lt;/script&gt;&lt;p&gt;
Here, since \(sin(x)\) has a period of \(2*\pi\), we need to scale our state
variable by that so it loops properly.
&lt;/p&gt;

&lt;p&gt;
&lt;a href="https://imois.in/posts/"&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
In code, this is as easy as:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// APPLY&lt;/span&gt;
&lt;span class="n"&gt;ball&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PI&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_animationPerc&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
By doing this to both the x and y axis at the same time, offset by a bit, we can get a circle!
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;canvas id="balls2" class="light_border" width="400" height="300"&gt; Your browser sucks :c. &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Anim 3:&lt;/span&gt; Circles&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt; new BouncingBalls('balls2', 2, 1); &lt;/script&gt;&lt;p&gt;
Which, again, in code is just:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// APPLY&lt;/span&gt;
&lt;span class="n"&gt;ball&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PI&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_animationPerc&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;ball&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PI&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_animationPerc&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// NOTE Equilivent to: ball.y = sin(2 * Math.PI * _animationPerc + Math.PI);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This idea can be taken much further, and leads to some really cool movements!
The &lt;a href="https://en.wikipedia.org/wiki/Lissajous_curve"&gt;Lissajous Curves&lt;/a&gt; are created when you scale the x and y parts differently in
a way very similar to above ^. That's a whole different blog post though!
&lt;/p&gt;


&lt;div id="orgccc0e32" class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/procedural_anim/1lissajous.gif" alt="1lissajous.gif" width="400px"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 3: &lt;/span&gt;The different shapes that can be made by scaling the inputs to sin/cos into different ratios. If these were animated like the ball above, the ball would follow the shape.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org17b64fc" class="outline-2"&gt;
&lt;h2 id="org17b64fc"&gt;Zigzag&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org17b64fc"&gt;
&lt;p&gt;
This is a slighly harder example for the idea of manipulating function shapes.
&lt;/p&gt;

&lt;p&gt;
We start off with our input shape as before… And keeping in mind our goal output shape (to get
the animation above).
&lt;/p&gt;

&lt;div id="org6e39c73" class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/procedural_anim/zigzag0.png" alt="zigzag0.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 4: &lt;/span&gt;Input _animationPerc (Blue), compared to the shape we need (Orange).&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
We can perform several steps to transform it into the right shape… Scaling it
up by 2 and moving it down by 1 (Orange). Then we can take the absolute value of
this (Green).
&lt;/p&gt;

&lt;div id="org3f7b225" class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/procedural_anim/zigzag1.png" alt="zigzag1.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 5: &lt;/span&gt;Input (Blue), scaled &amp;amp; transformed (Orange), result (Green)&lt;/p&gt;
&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// APPLY&lt;/span&gt;
&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;zigzag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Mathf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;ball&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;zigzag&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_dist&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb43262e" class="outline-2"&gt;
&lt;h2 id="orgb43262e"&gt;Bouncing balls&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb43262e"&gt;
&lt;p&gt;
In order to create a realistic bounce, we have to first construct the right
shape function again. Without delving into the physics of it, we're looking for
a Parabola: Some function of \(t^2\).
&lt;/p&gt;


&lt;div id="orgf5af615" class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/procedural_anim/bounce0.png" alt="bounce0.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 6: &lt;/span&gt;Input (Blue), vs bounce shape (Orange)&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Interestingly, we can get this shape from our zigzag before, by applying an
extra transformation: 1-zigzag&lt;sup&gt;2&lt;/sup&gt;.
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;canvas id="balls4" class="light_border" width="400" height="300"&gt; Your browser sucks :c. &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Anim 5:&lt;/span&gt; Bouncing balls&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt; new BouncingBalls('balls4', 4, 1); &lt;/script&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// APPLY&lt;/span&gt;
&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;zigzag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Mathf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;ball&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;zigzag&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;zigzag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_dist&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb86300c" class="outline-2"&gt;
&lt;h2 id="orgb86300c"&gt;More Ideas&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb86300c"&gt;
&lt;p&gt;
We can clamp zigzag so it's 1 for some time, which means
the ball will sit on the ground for a bit… By animating the scaling too, maybe this could
be an animation for a slime NPC?
&lt;/p&gt;


&lt;div id="org2665f0c" class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/procedural_anim/bounce1.png" alt="bounce1.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 7: &lt;/span&gt;Basic zigzag curve (Blue), zigzag/0.8 and clamped between 0 and 1 (Orange), and finally the output shape - bouncing ball with a pause (Green).&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
And how it looks animated…
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;canvas id="balls5" class="light_border" width="400" height="300"&gt; Your browser sucks :c. &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Anim 6:&lt;/span&gt; Bouncing balls&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt; new BouncingBalls('balls5', 5, 1); &lt;/script&gt;&lt;p&gt;
And also we can have loads of balls by just adding an offset for the &lt;b&gt;State&lt;/b&gt;
value to each one! With some polish this could maybe make a kind of snake creature for a game…
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;canvas id="balls6" class="light_border" width="400" height="300"&gt; Your browser sucks :c. &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Anim 7:&lt;/span&gt; Bouncing balls&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt; new BouncingBalls('balls6', 6, 10); &lt;/script&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgea00525" class="outline-2"&gt;
&lt;h2 id="orgea00525"&gt;Other applications&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgea00525"&gt;
&lt;p&gt;
While here, I've only done animations by moving things, it's also possible to
animate rotations, shaders, skeletons, and more with exactly the same ideas.
&lt;/p&gt;

&lt;p&gt;
Tune in for part 3 when I'll cover a more complicated idea: Using
gradient descent for solving constraints in procedural animation (but with fun
interactive animations!!).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description><category>animation</category><category>gamedev</category><category>programming</category><guid>https://imois.in/posts/procedural-animation-2-functions/</guid><pubDate>Sat, 27 Apr 2019 23:00:48 GMT</pubDate></item><item><title>Procedural Animation 1: State Machines</title><link>https://imois.in/posts/procedural-animation-1-state-machines/</link><dc:creator>Oisin Carroll</dc:creator><description>&lt;div id="outline-container-org9e16965" class="outline-2"&gt;
&lt;h2 id="org9e16965"&gt;Intro&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9e16965"&gt;
&lt;p&gt;
This is the first in a 3 part series on procedural animation, all taken from a talk
I gave in January of 2019. The posts ramp up in complexity, and I've tried to make
the animations interactive where possible!
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;This first post justifies and covers a general mentality I have for working on
procedural animations, and applies it to a simple example.&lt;/li&gt;
&lt;li&gt;
&lt;a href="https://imois.in/posts/procedural-animation-2-functions/"&gt;The second post&lt;/a&gt; gives a more powerful and harder tool - talking about function
shapes, and how you can build more complex behavour by combining simple movements.&lt;/li&gt;
&lt;li&gt;The third and final post (coming soon) covers inverse kinematics, and generally how to
approximate solutions much harder problems using gradient descent.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
All of the animations are running in javascript canvas, so you can open the
source code in the inspector or find it on &lt;a href="https://github.com/oisincar/imois.in/tree/src/files/assets/js/procedural_animation"&gt;my github for the site!&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org404ce48" class="outline-2"&gt;
&lt;h2 id="org404ce48"&gt;Differences vs traditional animation.&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org404ce48"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Advantages:
&lt;ul class="org-ul"&gt;
&lt;li&gt;Greater (infinite?) variety.
Simulate large numbers easily.&lt;/li&gt;
&lt;li&gt;Can react to player/ world better.&lt;/li&gt;
&lt;li&gt;When done well: More realistic.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;

&lt;li&gt;Disadvantages:
&lt;ul class="org-ul"&gt;
&lt;li&gt;Loss of control. Can be harder to tweak.&lt;/li&gt;
&lt;li&gt;Hard to get very charachterful movement. Can look robotic
(Unless that's intentional…)&lt;/li&gt;
&lt;li&gt;When it breaks it often breaks hard.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3a47468" class="outline-2"&gt;
&lt;h2 id="org3a47468"&gt;State, Update &amp;amp; Apply&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3a47468"&gt;
&lt;p&gt;
This is the core of how I approach these animations. I find it's helpful to try
and break down the system into 3 parts - State, Update, and Apply. These
systems can very easily become hard to tweak and work with, and this is just one
tool that might help with that.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;
&lt;b&gt;State&lt;/b&gt;:
&lt;ul class="org-ul"&gt;
&lt;li&gt;One or more variables, no logic.&lt;/li&gt;
&lt;li&gt;All we need to know to draw a frame&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;b&gt;Update&lt;/b&gt;:
&lt;ul class="org-ul"&gt;
&lt;li&gt;Changes (only) state variables on each frame or update cycle.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;b&gt;Apply&lt;/b&gt;:
&lt;ul class="org-ul"&gt;
&lt;li&gt;Move and/or draw stuff according to state.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
Each part can be thought about separately, and by moving the state into a clear
separate variable the system becomes much easier to reason about. Animations
won't go out of sync, and it's to debug as you can just view and edit the state directly.
&lt;/p&gt;

&lt;p&gt;
Anyway… Lets look at an example!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org56c40d8" class="outline-2"&gt;
&lt;h2 id="org56c40d8"&gt;Example: Light&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org56c40d8"&gt;
&lt;p&gt;
State machines are one of the simplest forms of procedural animation. The idea
is there is a single 'state' we're in, and also a set of
rules for why/ when we change state. State machines are often used in game AI -
where states might be { &lt;b&gt;Defend&lt;/b&gt;, &lt;b&gt;Rush&lt;/b&gt;, &lt;b&gt;Flank&lt;/b&gt; }, or for a character: { &lt;b&gt;Falling&lt;/b&gt;,
&lt;b&gt;Walking&lt;/b&gt;, &lt;b&gt;Sprinting&lt;/b&gt;, &lt;b&gt;Attacking&lt;/b&gt; }.
&lt;/p&gt;

&lt;p&gt;
Here we've just got a light, our &lt;b&gt;State&lt;/b&gt; is one of: { &lt;b&gt;On&lt;/b&gt;, &lt;b&gt;Off&lt;/b&gt; }.
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;canvas id="lightswitch" class="light_border" width="400" height="300"&gt; Your browser sucks :c. &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Anim 1:&lt;/span&gt; Randomly flickering light.&lt;/p&gt;
&lt;/div&gt;
&lt;script src="https://imois.in/assets/js/procedural_animation/LightSwitch.js"&gt;&lt;/script&gt;&lt;p&gt;
The second part of State, Update, Apply: &lt;b&gt;Update&lt;/b&gt;, is also simple. We randomly
choose to either stay in the current state or move to the other. I found
a \(98\%\) chance to stay &lt;b&gt;On&lt;/b&gt; and a \(93\%\) chance to stay &lt;b&gt;Off&lt;/b&gt; works decently.
&lt;/p&gt;

&lt;p&gt;
We can view the state and the transitions as a graph, where the arrows denote
probabilities.
&lt;/p&gt;


&lt;div id="org27efeb2" class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/procedural_anim/light_state.png" alt="light_state.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 1: &lt;/span&gt;Light state diagram&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
And finally, our Apply section simply determines if we should draw a circle that
frame, or leave the frame blank.
&lt;/p&gt;

&lt;p&gt;
Overall, our code looks like this…
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// STATE&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;_on&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;dt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// UPDATE:&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_on&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;Random&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mf"&gt;0.98&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="n"&gt;_on&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;_on&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;Random&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mf"&gt;0.93&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="n"&gt;_on&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// APPLY:&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_on&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="c1"&gt;// Draw here!!&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Tune in next time for some more interesting examples!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description><category>animation</category><category>gamedev</category><category>programming</category><guid>https://imois.in/posts/procedural-animation-1-state-machines/</guid><pubDate>Thu, 25 Apr 2019 23:00:48 GMT</pubDate></item></channel></rss>