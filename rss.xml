<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>im_oisin</title><link>https://imois.in/</link><description>A home for my random programming &amp; maths projects.</description><atom:link href="https://imois.in/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2019 &lt;a href="mailto:oisincar@gmail.com"&gt;Oisin Carroll&lt;/a&gt; </copyright><lastBuildDate>Sun, 01 Dec 2019 01:55:48 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Procedural Animation 3: Gradient Descent</title><link>https://imois.in/posts/procedural-animation-3-gradient-descent/</link><dc:creator>Oisin Carroll</dc:creator><description>&lt;div id="outline-container-org3d3b6cd" class="outline-2"&gt;
&lt;h2 id="org3d3b6cd"&gt;Intro&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3d3b6cd"&gt;
&lt;script type="text/javascript" src="https://unpkg.com/vis-graph3d@latest/dist/vis-graph3d.min.js"&gt;&lt;/script&gt;&lt;script src="https://imois.in/assets/js/procedural_animation/Global.js"&gt;&lt;/script&gt;&lt;script src="https://imois.in/assets/js/procedural_animation/Arm.js"&gt;&lt;/script&gt;&lt;script src="https://imois.in/assets/js/procedural_animation/ArmCanvas.js"&gt;&lt;/script&gt;&lt;script src="https://imois.in/assets/js/procedural_animation/Graph.js"&gt;&lt;/script&gt;&lt;script src="https://imois.in/assets/js/procedural_animation/GradientDescent2Link.js"&gt;&lt;/script&gt;&lt;script src="https://imois.in/assets/js/procedural_animation/TwoLinkArmAndGraph.js"&gt;&lt;/script&gt;&lt;script src="https://imois.in/posts/jquery.ui.touch-punch.min.js"&gt;&lt;/script&gt;&lt;p&gt;
In this third and final section, we'll cover how to solve harder problems that don't
necessarily have a single solution, or ones that have solutions that can't be
written as an equation of known variables.
&lt;/p&gt;

&lt;p&gt;
If you haven't read &lt;a href="https://imois.in/posts/procedural-animation-1-state-machines/"&gt;Part 1&lt;/a&gt;, we covered some simple state machines and some
general ideas on how I try to approach these kind of problems.
&lt;/p&gt;

&lt;p&gt;
You might also want to check out &lt;a href="https://imois.in/posts/procedural-animation-2-functions"&gt;Part 2&lt;/a&gt;, where we went over how to build up more
complex movement by combining functions of state.
&lt;/p&gt;

&lt;p&gt;
And finally, all of the (interactive!) animations here are running in javascript canvas, so you can open the
source code in the inspector or find it on &lt;a href="https://github.com/oisincar/imois.in/tree/src/files/assets/js/procedural_animation"&gt;my github for the site!&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf61ba63" class="outline-2"&gt;
&lt;h2 id="orgf61ba63"&gt;What we'll make!&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf61ba63"&gt;
&lt;p&gt;
These tenticles/ arms/ vines might make a fun enemy or background in a game, but
also demonstrate an idea that can be used to solve all kinds of problems! The
same idea (gradient descent) is the backbone of a huge amount of modern AI -
used to improve Google's results, autonomous cars, and more… And all you
need to understand it is a basic knowledge of derivitives.
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;!-- Arm --&gt;
    &lt;canvas id="intro-demo-arms" class="light_border" width="400" height="300" style="max-width: 85vw;"&gt;
        Your browser doesn't support html5 canvas :c.
    &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Anim 1:&lt;/span&gt; Reaching arms with 20 and 100 segments. Click &amp;amp; Drag to move the ball!&lt;/p&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
class GradientDescentLongChain {

    constructor(id) {
        var self = this;

        var armC = new ArmCanvas(
            document.getElementById(id),
            function(){self.finished = false;});

        this.arm = new Arm(20, 300, -250);
        this.arm2 = new Arm(100, 100, -50);

        armC.addArm(this.arm);
        armC.addArm(this.arm2);

        // Double arm length
        this.arm._lengths = this.arm._lengths.map(function(x) { return x*1.7; });
        this.arm2._angles = this.arm2._angles.map(function(x) { return 0; });

        var doUpdate = true;
        if (doUpdate)
            setInterval(function() { self.update(); }, self.interval);
    }

    improve(arm) {
        // var grads = this.arm.calculateCurrentGradients();
        var grads = arm.calculateCurrentGradientsSq();

        // Update arm angles!
        for (var i = 0; i &lt; grads.length; i++) {
            arm.changeAngle(i, -grads[i]*0.00001);
        }

        // If we're now close enough, don't update til we have to again.
        if (arm.getCurrentError() &lt; 0.05) {
            return true;
        }
        return false;
    }

    update() {
        // Only do stuff if we're not already at the target.
        if (!this.finished) {
            // Finished if both arms are finished
            var a1 = this.improve(this.arm);
            var a2 = this.improve(this.arm2);
            this.finished = a1 &amp;&amp; a2;
        }
    }
}

var b = new GradientDescentLongChain('intro-demo-arms');
&lt;/script&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org45ca79e" class="outline-2"&gt;
&lt;h2 id="org45ca79e"&gt;The problem: Kinematics&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org45ca79e"&gt;
&lt;p&gt;
Generally, (and according to google) kinematics is a branch of mechanics that
deals with the features or properties of the motion of an object. It's often
refered to as the "Geometry of Motion". For charachter animation, we usually
deal with Kinematics of Simple Chains - or limbs…
&lt;/p&gt;

&lt;p&gt;
For a given arm, &lt;b&gt;Forward Kinematics&lt;/b&gt; is working out where the hand (or end) is
in space given the angles between the shoulder, and upper and lower arms. The
opposite of this, called &lt;b&gt;Inverse Kinematics&lt;/b&gt; (IK), is where you have a fixed
target point and instead want to choose the same angles so the hand is as close
to it as possible.
&lt;/p&gt;

&lt;dl class="org-dl"&gt;
&lt;dt&gt;&lt;b&gt;Forward Kinematics:&lt;/b&gt;&lt;/dt&gt;
&lt;dd&gt;Your upper arm is at \(\alpha\) to your torso, and your
upper arm is \(\beta\) to your lower arm, where is your hand?&lt;/dd&gt;

&lt;dt&gt;&lt;b&gt;Inverse Kinematics:&lt;/b&gt;&lt;/dt&gt;
&lt;dd&gt;You want to reach for a ball infront of you, what
angles should you have at your shoulder and elbow?&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;
We're going to look at the second one. Inverse Kinematics are used for all kinds
of charachter animation, robotics, and predicting people's location in VR. It'd
be pretty useful to have a way to solve it!
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;span class="align_all"&gt;
        &lt;div&gt;
            &lt;!-- Arm --&gt;
            &lt;canvas id="twolinkarmandgraph_smp" class="light_border" width="400" height="300" style="max-width: 85vw;"&gt;
                Your browser doesn't support html5 canvas :c.
            &lt;/canvas&gt;&lt;!-- Sliders --&gt;&lt;span class="slider_row"&gt;
                &lt;span class="slider_label"&gt;Shoulder Angle (α)&lt;/span&gt;
                &lt;span id="ang1_smp" class="flat-slider"&gt;&lt;/span&gt;
                &lt;span type="text" id="ang1val_smp" class="slider_text"&gt;&lt;/span&gt;
            &lt;/span&gt;

            &lt;span class="slider_row"&gt;
                &lt;span class="slider_label"&gt;Elbow Angle (β)&lt;/span&gt;
                &lt;span id="ang2_smp" class="flat-slider"&gt;&lt;/span&gt;
                &lt;span type="text" id="ang2val_smp" class="slider_text"&gt;&lt;/span&gt;
            &lt;/span&gt;
        &lt;/div&gt;
    &lt;/span&gt;
    &lt;p&gt;&lt;span class="figure-number"&gt;Anim 1:&lt;/span&gt; The problem: Trying to reach for the ball by changing the angles of both joints. How can we find these angles?&lt;/p&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;
{
    function UpdateGraph() {}
    // Create an arm in that space
    var armC = new ArmCanvas(document.getElementById('twolinkarmandgraph_smp'), UpdateGraph);
    armC.targetX = 27;
    armC.targetY = 13;

    var arm = new Arm(2);
    armC.addArm(arm);

    this.arm = arm;

    // slider
    $("#ang1_smp").slider({
        min: 0,
        max: 180,
        values: [arm.getAngle(0)],
        slide: function(event, ui) {
            $("#ang1val_smp").text(ui.values[0] + "°")
            arm.setAngle(0, ui.values[0]);
        }
    });
    $("#ang1val_smp").text(arm.getAngle(0) + "°");

    $("#ang2_smp").slider({
        min: -160,
        max: 160,
        values: [arm.getAngle(1)],
        slide: function(event, ui) {
            $("#ang2val_smp").text(ui.values[0] + "°");
            arm.setAngle(1, ui.values[0]);
        }
    });
    $("#ang2val_smp").text(arm.getAngle(1) + "°");
}
&lt;/script&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgec989be" class="outline-2"&gt;
&lt;h2 id="orgec989be"&gt;Simple arms in 2d&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgec989be"&gt;
&lt;p&gt;
For the 2D case, and when there are only two joints in the arm, there are (usually) two solutions - an
'elbows up' position, and an 'elbows down' one.
&lt;/p&gt;

&lt;p&gt;
Of course, there are cases where there are no solution. If the ball is out of
reach, for example.
&lt;/p&gt;

&lt;p&gt;
It's possible to work out these two angles with coordinate geometry or a bit of
trig, as long as you have the lengths of both arm segments and the target
location. However, as there's a million other gamedev sites, robotics courses,
and random medium posts, so I'll won't explain it here again. It is a fun problem
though - I'd recommend giving it a go!
&lt;/p&gt;

&lt;p&gt;
It's also worth noting problems and limbs in 3D can be solved using the same 2D algorithm/equation
with one trick: An 'elbow target'. We add a point that, given the choice, the
elbow will be as near to as possible. This (interestingly) causes all 5 points: Shoulder, Elbow,
Hand, Hand Target, and Elbow Target to all lie in the same plane. We can take
the plane defined by the fixed points: Shoulder, Hand Target, and Elbow Target
and solve the problem in 2d on that plane. This is how a lot of kinematics in
games is done.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge55b096" class="outline-2"&gt;
&lt;h2 id="orge55b096"&gt;Harder problems.. I.e. Arms with more joints..?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge55b096"&gt;
&lt;p&gt;
It's not possible to solve harder problems using the same idea however, if you
add an extra segment to the arm there suddenly isn't a way to find solutions
(mostly because there are now likely infinite solutions…).
&lt;/p&gt;

&lt;p&gt;
This is what I wanted to write about… How can you find approximate or fast
solutions to a problem that's much harder to solve exactly, or find 'organic'
solutions to some problem that has a lot of possible solutions.
&lt;/p&gt;

&lt;p&gt;
Instead of trying to find a solution instantly, we take the current position of
the arm and figure out how to improve it slightly. The solution is then
calculated itteratively, looping over and over either until we're not getting
any closer or we're within some distance.
&lt;/p&gt;

&lt;p&gt;
Because we're only 3 dimensional creatures… The solution is easiest to
describe for arms with 2 joints… But the maths works for any number of joints.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9fa87c3" class="outline-2"&gt;
&lt;h2 id="org9fa87c3"&gt;Forward Kinematics&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9fa87c3"&gt;
&lt;p&gt;
First, we need to work out where the end of our arm is… We write the angle at
the shouder as \(\alpha\), and at the elbow as \(\beta\). The length of the upper
arm is \(l1\), and forearm is \(l2\). I take the shoulder to be at \((0,0)\)
&lt;/p&gt;

&lt;p&gt;
To do this, we can split it into 2 parts. The position of the elbow will be at:
&lt;/p&gt;

\begin{align*}
Elbow_x &amp;amp; = l1 * sin(\alpha) \\
Elbow_y &amp;amp; = l1 * cos(\alpha)
\end{align*}

&lt;p&gt;
Then, similarly, we can work out the position of the hand relative to the elbow.
This is a little harder to see, but we can take the angle of the arm relative to
the ground (\(\alpha + \beta\)) and use the same trig formula.
&lt;/p&gt;

\begin{align*}
Hand_x - Elbow_x &amp;amp; = l2 * sin(\alpha + \beta) \\
Hand_y - Elbow_y &amp;amp; = l2 * cos(\alpha + \beta)
\end{align*}

&lt;p&gt;
Then the position of the hand is simply the sum.
&lt;/p&gt;

\begin{align*}
Hand_x &amp;amp; = l1 * sin(\alpha) + l2 * sin(\beta - \alpha) \\
Hand_y &amp;amp; = l1 * cos(\alpha) + l2 * cos(\beta - \alpha)
\end{align*}
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org937fea5" class="outline-2"&gt;
&lt;h2 id="org937fea5"&gt;Distance function&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org937fea5"&gt;
&lt;p&gt;
In order to perform gradient descent, we need a formula for the error we're
trying to reduce. This is the distance from our hand to our target. Ideally, we
want this distance to be 0, which'd mean our hand is exactly on the target.
&lt;/p&gt;

&lt;p&gt;
The distance in x and y can be written from the above. Here \(|x|\) means the
absolute value of x, or the non-negative value of x.
&lt;/p&gt;

\begin{align*}
Dist_x &amp;amp; = | Target_x - (l1 * sin(\alpha) + l2 * sin(\alpha + \beta)) | \\
Dist_y &amp;amp; = | Target_y - (l1 * cos(\alpha) + l2 * cos(\alpha + \beta)) |
\end{align*}

&lt;p&gt;
Then using pythagoras the distance is:
&lt;/p&gt;

\begin{align*}
Dist = \sqrt{Dist_x^2 - Dist_y^2}
\end{align*}

&lt;p&gt;
We can look at this distance for any value of \(\alpha\) and \(\beta\). If we plot
\(\alpha\) and \(\beta\) on the x and y coordinates of a graph, and the
corrisponding distance the arm is from the target the z (vertical) axis, we can
view the distance as a shape.
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;span class="align_all"&gt;
        &lt;div&gt;
            &lt;!-- Arm --&gt;
            &lt;canvas id="twolinkarmandgraph" class="light_border" width="600" height="300" style="max-width: 85vw;"&gt;
                Your browser doesn't support html5 canvas :c.
            &lt;/canvas&gt;&lt;!-- Sliders --&gt;&lt;span class="slider_row"&gt;
                &lt;span class="slider_label"&gt;Shoulder Angle (α)&lt;/span&gt;
                &lt;span id="ang1" class="flat-slider"&gt;&lt;/span&gt;
                &lt;span type="text" id="ang1val" class="slider_text"&gt;&lt;/span&gt;
            &lt;/span&gt;

            &lt;span class="slider_row"&gt;
                &lt;span class="slider_label"&gt;Elbow Angle (β)&lt;/span&gt;
                &lt;span id="ang2" class="flat-slider"&gt;&lt;/span&gt;
                &lt;span type="text" id="ang2val" class="slider_text"&gt;&lt;/span&gt;
            &lt;/span&gt;

            &lt;span class="slider_row"&gt;
                &lt;span class="slider_label"&gt;Upper Arm Len&lt;/span&gt;
                &lt;span id="l1" class="flat-slider"&gt;&lt;/span&gt;
                &lt;span type="text" id="l1val" class="slider_text"&gt;&lt;/span&gt;
            &lt;/span&gt;

            &lt;span class="slider_row"&gt;
                &lt;span class="slider_label"&gt;Forearm Len&lt;/span&gt;
                &lt;span id="l2" class="flat-slider"&gt;&lt;/span&gt;
                &lt;span type="text" id="l2val" class="slider_text"&gt;&lt;/span&gt;
            &lt;/span&gt;

        &lt;/div&gt;
        &lt;div id="mygraph" style="max-width: 85vw;"&gt;&lt;/div&gt;
    &lt;/span&gt;
    &lt;script&gt; var a = new TwoLinkArmAndGraph(); &lt;/script&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Anim 2:&lt;/span&gt; The distance function for any of the shoulder and elbow angles.
    On the graph: Click to pan, scroll wheel to zoom, and mouse over to see the distance/angles at any point. Try messing around
    with the angles and arm lengths, or move the target ball!&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Each point on the surface corrisponds to some shoulder and elbow angles, and the
height (or colour) there corrisponds to the distance those angles put the hand
from the target. As you change the angles of the arms, you can see the graph
translate - the center of it shows the current elbow and shoulder angles.
&lt;/p&gt;

&lt;p&gt;
You can make some neat patterns by tweaking the arm lengths and target position.
Try putting the ball on the base of the arm…
&lt;/p&gt;

&lt;p&gt;
Our goal will be effectively to try and find the lowest point on this surface -
the angles there will bring our arm closest to our target ball.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd8f47b7" class="outline-2"&gt;
&lt;h2 id="orgd8f47b7"&gt;Gradient Descent&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgd8f47b7"&gt;
&lt;p&gt;
We can use the derivitive of this distance function to improve our errors.
First, write the distance corrisponding to \(\alpha\) and \(\beta\) as \(Dist(\alpha, \beta)\).
&lt;/p&gt;

&lt;p&gt;
Then we can consider the partial derivitive with respect to the angles.
&lt;/p&gt;

\begin{align*}
\frac{\partial Dist}{\partial \alpha}
\end{align*}

&lt;p&gt;
This works out to a single value, and can be read/ thought of as 'how does the
distance to the target change when I change \(\alpha\) by a very small amount'.
&lt;/p&gt;

&lt;p&gt;
For example if \(\frac{\partial Dist}{\partial \alpha}\) is positive, then
increasing \(\alpha\) will bring increase the distance. Decreasing \(\alpha\) then brings
hand towards the target. If the derivitive is negative, we
should instead increase \(\alpha\) by a small amount to improve our hand position.
This can be written as:
&lt;/p&gt;

\begin{align*}
\alpha := \alpha - k * \frac{\partial Dist}{\partial \alpha}
\end{align*}

&lt;p&gt;
Here k is a small value, in the animations I have it set to 0.0001. This means
each update loop we update alpha to move the hand a little closer.
&lt;/p&gt;

&lt;p&gt;
The maths is exactly the same for the elbow position:
&lt;/p&gt;

\begin{align*}
\beta := \beta - k* \frac{\partial Dist}{\partial \beta}
\end{align*}

&lt;p&gt;
And for any number of limbs.
&lt;/p&gt;

&lt;p&gt;
This method of improving is called 'gradient descent', because if we look at the
surface, each time we update we travel down the surface until we reach the bottom.
&lt;/p&gt;

&lt;p&gt;
The demos just perform this update once per frame, but it's easy to completely
solve the system by running for more itterations.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgcac89be" class="outline-2"&gt;
&lt;h2 id="orgcac89be"&gt;Implementation &amp;amp; Extras&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgcac89be"&gt;
&lt;p&gt;
It might help to look through the source code for the animations (embedded into
this page), or available &lt;a href="https://github.com/oisincar/imois.in/blob/master/assets/js/procedural_animation/Arm.js"&gt;here on Github&lt;/a&gt;. You're free to lift this for anything,
the code's CC0!
&lt;/p&gt;

&lt;p&gt;
Here's a bonus of what happens when you accidentally make 3 arms compete for who
renders at the same time…
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;!-- Arm --&gt;
    &lt;canvas id="twolinkgrad_arm_canvas_broken" class="light_border" width="500" height="400" style="max-width: 85vw;"&gt;
        Your browser doesn't support html5 canvas :c.
    &lt;/canvas&gt;&lt;script&gt;
      new GradientDescent2Link('twolinkgrad_arm_canvas_broken', 2);
      new GradientDescent2Link('twolinkgrad_arm_canvas_broken', 4);
      new GradientDescent2Link('twolinkgrad_arm_canvas_broken', 15);
    &lt;/script&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Anim 3:&lt;/span&gt; Glitchy movement, could be a neat effect for a Stranger Things monster..?&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Anyway, I hope this helped! Gradient descent is a very powerful tool for solving
any kind of problem if you're able to express it in a certain way. For more
procedural animation stuff, you might be interested in &lt;a href="https://imois.in/posts/procedural-animation-1-state-machines/"&gt;Part 1&lt;/a&gt; where I looked at
some core ideas and a light animation, or &lt;a href="https://imois.in/posts/procedural-animation-2-functions"&gt;Part 2&lt;/a&gt; with some more fancy function
ideas and shapes.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description><category>animation</category><category>gamedev</category><category>math</category><category>programming</category><guid>https://imois.in/posts/procedural-animation-3-gradient-descent/</guid><pubDate>Tue, 26 Nov 2019 00:22:20 GMT</pubDate></item><item><title>Jack Boyce's Siteswap Questions</title><link>https://imois.in/posts/jack-boyces-siteswap-questions/</link><dc:creator>Oisin Carroll</dc:creator><description>&lt;div id="outline-container-org7e66151" class="outline-2"&gt;
&lt;h2 id="org7e66151"&gt;Intro&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org7e66151"&gt;
&lt;p&gt;
At EJC last year (2018), I came across Jack Boyce's siteswap questions, which
can be found &lt;a href="http://www.juggling.org/help/siteswap/tests/test-boyce.html"&gt;HERE!&lt;/a&gt; I'd highly recommend giving them a go. They start off doable,
and at the end work up to a derivation of how many siteswaps of a given length
there are.
&lt;/p&gt;

&lt;p&gt;
I ended up getting a bit carried away, and writing some programs to visualize
parts of the questions, and take some ideas further. The full source for generating
the graphs can be found &lt;a href="https://github.com/oisincar/siteswap_graph"&gt;on my Github.&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
I wrote almost all of this at the time, but I'm only getting around to cleaning
it up and posting it now… 9 months later.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb6ef169" class="outline-2"&gt;
&lt;h2 id="orgb6ef169"&gt;q1&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb6ef169"&gt;
&lt;p&gt;
&lt;i&gt;I am juggling \(868671\) with clubs (yeah, right).  How many do I have?&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
The number of objects in a given siteswap is just the average value, I.e. The
sum of the numbers divided by the length.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;div&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Answer: 6
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1f3a068" class="outline-2"&gt;
&lt;h2 id="org1f3a068"&gt;q2&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1f3a068"&gt;
&lt;p&gt;
&lt;i&gt;I have a bowling ball that I can only throw as a site swap '\(3\)' throw. Which&lt;/i&gt;
&lt;i&gt;of the following patterns can I theoretically run, using the bowling ball in addition to 3 normal balls:&lt;/i&gt;
&lt;/p&gt;
&lt;div class="org-center"&gt;
&lt;p&gt;
&lt;i&gt;a) \(53\)     b) \(6631\)    c) \(633\)    d) \(577131\)&lt;/i&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
This is a question about orbits. A siteswap throw is thrown it's value number of
beats later (e.g. a \(6\) is thrown 6 beats later). Therafore we're looking for
siteswaps which have a \(3\) every 3 beats (wrapping).
&lt;/p&gt;

&lt;p&gt;
This is only c).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org38deda5" class="outline-2"&gt;
&lt;h2 id="org38deda5"&gt;q3&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org38deda5"&gt;
&lt;p&gt;
&lt;i&gt;You are doing a 4 ball fountain and decide you want to switch into&lt;/i&gt;
&lt;i&gt;741, an excited state site swap.  You can't just start throwing:&lt;/i&gt;
&lt;i&gt;4444741741… Since the last fountain throw (4) will collide with the&lt;/i&gt;
&lt;i&gt;first 1 you do.  Some connecting throws are needed.  What is the&lt;/i&gt;
&lt;i&gt;shortest starting sequence for 741?&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
A 4 ball base fountain occurs in the base state of 4 balls, which can be written
as:
&lt;/p&gt;

&lt;pre class="example"&gt;
4|xxxx
&lt;/pre&gt;

&lt;p&gt;
741 occurs in state:
&lt;/p&gt;
&lt;pre class="example"&gt;
7|xx_x__x
4|x_xx_x
1|xxx_x
&lt;/pre&gt;

&lt;p&gt;
Before the 7 is thrown, we're in state &lt;code&gt;xxx_x&lt;/code&gt;, which is simply a \(5\)
away from the base state.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org05b9752" class="outline-2"&gt;
&lt;h2 id="org05b9752"&gt;q4&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org05b9752"&gt;
&lt;p&gt;
&lt;i&gt;You want to get back into the fountain, from 741.  What is the&lt;/i&gt;
&lt;i&gt;shortest connecting (ending) sequence in this direction?&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
From &lt;code&gt;xxx_x_&lt;/code&gt; to &lt;code&gt;xxxx___&lt;/code&gt;, we can throw a \(3\).
&lt;/p&gt;

&lt;p&gt;
It's not a coincidence that the the transition into \(741\) (\(5\)) and out (\(3\))
together make a valid siteswap (\(53\)). The intuition here is that you can
transition into any siteswap, repeat that siteswap any number of times, and
transition back. That includes repeating it 0 times. Therefore the transition
into and out of any siteswap must be, itself, a valid (ground state) pattern.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga509070" class="outline-2"&gt;
&lt;h2 id="orga509070"&gt;q5&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orga509070"&gt;
&lt;p&gt;
&lt;i&gt;Go from the 4 ball fountain to 714.  What are the shortest&lt;/i&gt;
&lt;i&gt;connecting sequences (both directions)?&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
As before we can work out the state that 714 starts in.
&lt;/p&gt;


&lt;pre class="example"&gt;
7|x_xx__x
1|xxx__x
4|xx_xx
&lt;/pre&gt;


&lt;p&gt;
Before the 7 is thrown, we're in state \(xx\_xx\). This is where we need our
transition to leave us. We can see it won't be possible to transition in a
single throw, so lets look at transitions of length 2.
&lt;/p&gt;

&lt;p&gt;
I.e. finding the throws a, b here:
&lt;/p&gt;
&lt;pre class="example"&gt;
4|xxxx
a|
b|xx_xx
&lt;/pre&gt;
&lt;p&gt;
For a and b, (and therefore the transition into the pattern) both \(55\) and \(64\) work.
&lt;/p&gt;

&lt;p&gt;
As for the transition back, a \(2\) works. Without having to check, we know this
will work because \(552\) and \(642\) are valid siteswaps.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgaeb2c34" class="outline-2"&gt;
&lt;h2 id="orgaeb2c34"&gt;q6&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgaeb2c34"&gt;
&lt;p&gt;
&lt;i&gt;You are already doing \(741\) and want to switch directly into \(714\).&lt;/i&gt;
&lt;i&gt;What is the shortest sequence for doing so?  [You could just&lt;/i&gt;
&lt;i&gt;concatenate the ending sequence found in (4) above and the starting&lt;/i&gt;
&lt;i&gt;sequence in (5), but this is not the shortest solution.]&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
Here, we're looking for the transition from \(xxx\_x\) to \(xx\_xx\). This is just a
\(5\).
&lt;/p&gt;

&lt;p&gt;
We can also see this by looking at the transitions we found into the siteswap.
For \(741\) we found \(5\), and for \(714\) we found \(55\). The difference here is just
an extra \(5\).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4f51a0c" class="outline-2"&gt;
&lt;h2 id="org4f51a0c"&gt;q7&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org4f51a0c"&gt;
&lt;p&gt;
&lt;i&gt;Is the trick \(66671777161\) simple?  If not, which portion of the&lt;/i&gt;
&lt;i&gt;pattern can be repeated within the larger trick?&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;i&gt;Is the trick \(6316131\) simple?  If not, which portion can be repeated?&lt;/i&gt;
&lt;/p&gt;


&lt;p&gt;
Here 'simple' (more commonly 'prime') refers to simple cycles in graph theory.
These are siteswaps where each state is only visited once. We could find answers
by working out all the states in each siteswaps, and look for duplicates. If
there's any duplicate, then the siteswap isn't simple, and the throws between
these duplicated states can be repeated. This can be done by brute force as
follows by generating the table by hand. I'm too lazy to do this so I'll write a
much longer program to do it instead… :thinking:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;-- Function mapping from current state to next state.&lt;/span&gt;
&lt;span class="c1"&gt;-- E.g. throw "xxxx___" 5 gives "xxx_x__"&lt;/span&gt;
&lt;span class="nf"&gt;throw&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;before&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="sc"&gt;'x'&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="n"&gt;after&lt;/span&gt;
    &lt;span class="kr"&gt;where&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;before&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="n"&gt;after&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;splitAt&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="s"&gt;"_"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;-- Juggle pattern 100 times, then take the next (length ss) state changes.&lt;/span&gt;
&lt;span class="c1"&gt;-- This creates a list of maps between starting state&lt;/span&gt;
&lt;span class="c1"&gt;-- (say, xxxx___), throw (e.g. 5), and resulting state (xxx_x__)&lt;/span&gt;
&lt;span class="nf"&gt;grEdges&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;take&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;drop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;scanl&lt;/span&gt; &lt;span class="n"&gt;nextEdge&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;[]&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;emptyState&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;concat&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;repeat&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kr"&gt;where&lt;/span&gt; &lt;span class="n"&gt;nextEdge&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;startState&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;endState&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;endState&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;endState&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
	&lt;span class="n"&gt;emptyState&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;replicate&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;maximum&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="sc"&gt;'_'&lt;/span&gt;

&lt;span class="c1"&gt;-- Print table for a given siteswap&lt;/span&gt;
&lt;span class="nf"&gt;printTable&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;putStrLn&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;unlines&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="n"&gt;showSt&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grEdges&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kr"&gt;where&lt;/span&gt; &lt;span class="n"&gt;showSt&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="s"&gt;"|"&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Then, we can get the tables for both siteswaps we're interested in.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;printTable&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="n"&gt;digitToInt&lt;/span&gt; &lt;span class="s"&gt;"66671777161"&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;xxxxx__&lt;/span&gt;
&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;xxxx_x_&lt;/span&gt;
&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;xxx_xx_&lt;/span&gt;
&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;xx_xxx_&lt;/span&gt;
&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;x_xxx_x&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;xxxx_x_&lt;/span&gt;
&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;xxx_x_x&lt;/span&gt;
&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;xx_x_xx&lt;/span&gt;
&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;x_x_xxx&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;xx_xxx_&lt;/span&gt;
&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;x_xxxx_&lt;/span&gt;

&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;printTable&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="n"&gt;digitToInt&lt;/span&gt; &lt;span class="s"&gt;"6316131"&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;xxx___&lt;/span&gt;
&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;xx___x&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;x_x_x_&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;xx_x__&lt;/span&gt;
&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;x_x__x&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;xx__x_&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;x_xx__&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org613677c" class="outline-3"&gt;
&lt;h3 id="org613677c"&gt;66671777161&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org613677c"&gt;
&lt;p&gt;
Here, there are two states that occur more than once. I've marked the pairs here
as a and b. This means you can juggle the patterns between the As (I.e. 6671,
and 7771616), and Bs (717771, and 61666)
&lt;/p&gt;

&lt;pre class="example"&gt;
1| xxxxx__
6| xxxx_x_ A
6| xxx_xx_
6| xx_xxx_ B
7| x_xxx_x
1| xxxx_x_ A
7| xxx_x_x
7| xx_x_xx
7| x_x_xxx
1| xx_xxx_ B
6| x_xxxx_
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5c8b178" class="outline-3"&gt;
&lt;h3 id="org5c8b178"&gt;6316131&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5c8b178"&gt;
&lt;p&gt;
Here, this siteswap has no duplicated states, and is therefore prime.
&lt;/p&gt;
&lt;pre class="example"&gt;
1| xxx___
6| xx___x
3| x_x_x_
1| xx_x__
6| x_x__x
1| xx__x_
3| x_xx__
&lt;/pre&gt;

&lt;p&gt;
We can also use this to make a graph of these patterns. Graphing them using
graphviz. This code prints into pretty much the Dot format used by graphviz, and the
resulting graphs are shown below.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;printGraph&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;putStrLn&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;unlines&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="n"&gt;showSt&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grEdges&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="kr"&gt;where&lt;/span&gt; &lt;span class="n"&gt;showSt&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;startSt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;endSt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"  "&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;startSt&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="s"&gt;" -&amp;gt; "&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;endSt&lt;/span&gt;
	  &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="s"&gt;" [label=&lt;/span&gt;&lt;span class="se"&gt;\"&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\"&lt;/span&gt;&lt;span class="s"&gt;]"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/siteswap_qs/ss1.png" alt="ss1.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 1: &lt;/span&gt;Siteswap map for 66671777161. We can see the two states we found (labeled A and B) before in the nodes with 2 input and output edges.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Here we can see the results for our first part, 66671777161. Any closed loop in this is a valid
siteswap, which are (hopefully) just the 4 we found before. Pretty neat!
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/siteswap_qs/ss2.png" alt="ss2.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 2: &lt;/span&gt;Siteswap map for 6316131&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
As expected, \(6316131\) is prime so the graph is simply a loop with no repeated states.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6a488c6" class="outline-2"&gt;
&lt;h2 id="org6a488c6"&gt;q8&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org6a488c6"&gt;
&lt;p&gt;
&lt;i&gt;There is 1 ground state 5 ball trick of length 1 (5), 2 of length 2&lt;/i&gt;
&lt;i&gt;(55, 64), 6 of length 3 (555, 564, 645, 663, 744, 753), 24 of length&lt;/i&gt;
&lt;i&gt;4, 120 of length 5, and 720 of length 6.  Clearly the pattern is N =&lt;/i&gt;
&lt;i&gt;L!, which is a big hint that L elements are being permuted.  What L&lt;/i&gt;
&lt;i&gt;things are permuted by ground state site swaps of length L?  (Bear in&lt;/i&gt;
&lt;i&gt;mind that L is not the number of balls.)&lt;/i&gt;
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/siteswap_qs/q8_1.png" alt="q8_1.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 3: &lt;/span&gt;A continuous 5 ball cascade, breaking for a period 4 siteswap, before resuming.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Looking at siteswaps of length 4, for example. Here, we can assign a, b, c, d to
whatever we want, but we're limited with what we can connect to. The question
becomes: How many ways can we connect up the arrows to form valid patterns.
&lt;/p&gt;

&lt;p&gt;
Any way that we can connect up these, so that every node has 0 or 1 throws going
to it, and the same number of throws leaving it will be a valid pattern.
&lt;/p&gt;

&lt;p&gt;
We can look at each throw in turn, and see what it's possible to connect it to.
a already receives a throw, so it can't be a 0. It can't connect to b, c, d, or
the following 5 because they already have arrows connecting to them.
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/siteswap_qs/q8_2.png" alt="q8_2.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 4: &lt;/span&gt;There are 4 possible values for a, shown in red.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Here, in red, are the possible throws from \(a\). \(a \in \{5,6,7,8\}\). It can be seen that b, c, and d,
can also throw to these same 4 positions. However, only one can throw to each.
We need to choose an ordering for these 4 throws to land. The number of ways to
order 4 objects is 4!. By this logic, we can see how it'll be \(l!\) for any number
of throws (until we start getting 0s… See next q).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb5df378" class="outline-2"&gt;
&lt;h2 id="orgb5df378"&gt;q9&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb5df378"&gt;
&lt;p&gt;
&lt;i&gt;There are not 7! = 5040 ground state 5 ball patterns of length 7,&lt;/i&gt;
&lt;i&gt;as the above pattern would suggest (the actual number is around&lt;/i&gt;
&lt;i&gt;4300). Why does the pattern break down?  Can you calculate (not by&lt;/i&gt;
&lt;i&gt;brute force!) how many ground state patterns there are for L =&lt;/i&gt;
&lt;i&gt;7,8,9,…?&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
This is due to there being 0s in the pattern. As before we can connect these
arrows in any way, but sometimes in later throws we won't have a ball to throw.
&lt;/p&gt;

&lt;p&gt;
Another way of approaching the previous question is to reverse it. Instead of
looking at the throws being made at a point, look instead at the number of
places the throws can come from.
look at the throws landing at a
point. a,b,c,d,e already have their throws chosen, so we're looking at the
subsequent 5 throws. Since we require a ball to land at
each of these times, we can just times together all the ways these arrows could
be directed.
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/siteswap_qs/q9_1.png" alt="q9_1.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 5: &lt;/span&gt;Here, the first cascade throw after the siteswap could come from any of a-e.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Here, there are a choice of 5 throws that can land at this time. For the
following throw, there are only 4 left, and after is 3 etc. This approach leads
us to the same answer as before: n!.
&lt;/p&gt;

&lt;p&gt;
Where this falls apart however is for longer sequences..
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/siteswap_qs/q9_2.png" alt="q9_2.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 6: &lt;/span&gt;f or g could be a 0, and so the arrows in blue may not be possible. This is the problem with our current method.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Here, this method falls apart - we don't know if f or g will even 'contain' a
ball for us to throw. Because of this, if we were to continue the previous
method - we'd overestimate the number of siteswaps of any given length.
&lt;/p&gt;

&lt;p&gt;
However, having a 0 in a pattern is pretty much the same as inserting a space
into a shorter siteswap. If we were able to work out the number of siteswaps of
a shorter length with no 0s, and then multiply it by the number of ways we could
'insert' a 0 into that siteswap… We'd be able to work out the number of
siteswaps of any given length despite there being 0s.
&lt;/p&gt;

&lt;p&gt;
Here's an example of this insertion… We can create all siteswaps with 0s
similarly by adding gaps into siteswaps without 0s.
&lt;/p&gt;

&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/siteswap_qs/q9_3.png" alt="q9_3.png"&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/siteswap_qs/q9_4.png" alt="q9_4.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 8: &lt;/span&gt;Siteswap 504 has exactly the same arrow placement as 33, but with an added 0. All siteswaps with 0s have exactly one siteswap without 0s they map to.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
So with this in mind, we can calculate the total number of siteswaps of length
\(L\) by:
&lt;/p&gt;

&lt;div class="org-center"&gt;
&lt;p&gt;
\(\sum_{l=1}^{L}\) (arrow permutations of length \(l\)) \(*\) (ways to insert \(L-l\) gaps into a siteswap of length \(l\))
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0616af9" class="outline-3"&gt;
&lt;h3 id="org0616af9"&gt;Arrow permutations:&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org0616af9"&gt;
&lt;p&gt;
To work out the permutations of length l, we can use the method we had before.
We go through the catches, and work out where the throw could've come from. Now
that we've no 0s, any unassigned throw before can be used.
&lt;/p&gt;

&lt;p&gt;
The first \(n\), where \(n\) is the number of balls are already determined by the
incoming cascade throws. After that, we have n throws that can land at any
point.
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/siteswap_qs/q9_5.png" alt="q9_5.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 9: &lt;/span&gt;The n (n = 5 here) throws that could arrive at f. After picking the throw to arrive at f, we'll still have n choices for g - since f is now a possible source.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
As long as the pattern is going, we have \(n\) places the throw could've been
made. We go through the siteswap from left to right, picking each throw source
in turn. Therafore, the number of possible sources remains the same - \(n\).
&lt;/p&gt;

&lt;p&gt;
From the previous question, for \(n\) throws following the pattern we have one
less choice each time, totalling \(n!\).
&lt;/p&gt;

&lt;p&gt;
The total number of arrow permutations therefore is
&lt;/p&gt;

&lt;p&gt;
\[ p = \begin{cases}
      l! &amp;amp; l &amp;lt;= n \\
      n! * n^{l-n} &amp;amp; otherwise
   \end{cases}
\]
&lt;/p&gt;

&lt;p&gt;
Since we already know how many ground state siteswaps there are for \(l &amp;lt;= n\),
(I.e. l!) we'll ignore this case for now.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org88637b2" class="outline-3"&gt;
&lt;h3 id="org88637b2"&gt;Gap insertion&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org88637b2"&gt;
&lt;p&gt;
Given a siteswap of length \(l\) with no gaps, we're looking to insert them so as
to end up with one of length \(L, L &amp;gt;= l\).
&lt;/p&gt;

&lt;p&gt;
Another way to phrase this is to say given a sequence of length \(L\), we have to
choose positions for the \(L-l\) gaps. We can't choose
the first \(n\) places though, since the siteswap is ground state.
&lt;/p&gt;

&lt;p&gt;
This is just \({L-n \choose L-l}\), as long as \({ L-n \geq L-l } \implies { l \geq
n }\). There is no way to insert gaps into a siteswap that's shorter than the
number of balls.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge8fd573" class="outline-3"&gt;
&lt;h3 id="orge8fd573"&gt;Putting it all together:&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge8fd573"&gt;
&lt;p&gt;
Lets insert what we have into the equation.
&lt;/p&gt;
&lt;div class="org-center"&gt;
&lt;p&gt;
\(\sum_{l=1}^{L}\) (arrow permutations of length \(l\)) \(*\) (ways to insert \(L-l\) gaps into a siteswap of length \(l\))
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Since there are 0 ways to insert gaps into siteswaps where \(n &amp;lt; L\), and we already know
from the previous question that the number of siteswaps in this case is \(L!\),
we'll omit this case and come back to it.
&lt;/p&gt;

&lt;p&gt;
\[ s(L, n) = \sum_{l=1}^{L} \bigg[ \begin{cases}
      l! &amp;amp; l &amp;lt;= n \\
      n! * n^{l-n} &amp;amp; otherwise
   \end{cases} * {L \choose l} \bigg] \]
&lt;/p&gt;

&lt;p&gt;
\[ = \sum_{l=n}^{L} \bigg[n! * n^{l-n} * {L-n \choose L-l} \bigg], l \geq n \]
&lt;/p&gt;

&lt;p&gt;
Which gives us the number of ground state siteswaps for a given number of balls (\(n\)) and
length (\(l, l \geq n\))! We can test it to get an answer for how many siteswaps of
length 7 there are:
&lt;/p&gt;

&lt;p&gt;
\[ s(7, 5) = \sum_{l=5}^{7} \bigg[5! * 5^{l-5} * {2 \choose 7-l} \bigg] =
5!(5^0*1 + 5^1*2 + 5^2*1) = 4320 \]
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org595b16c" class="outline-3"&gt;
&lt;h3 id="org595b16c"&gt;Simplify&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org595b16c"&gt;
&lt;p&gt;
We can simplify this formula a lot further! First taking \(n!\) out side the sum.
&lt;/p&gt;

&lt;p&gt;
\[ = n! * \sum_{l=n}^{L} \bigg[n^{l-n} * {L-n \choose L-l} \bigg] \]
&lt;/p&gt;

&lt;p&gt;
Substitute \(k+n = l\)
\[ = n! * \sum_{k=0}^{L-n} \bigg[n^{k} * {L-n \choose L-k-n} \bigg] \]
&lt;/p&gt;

&lt;p&gt;
Next, substitute \(L-n = d\)
\[ = n! * \sum_{k=0}^{d} \bigg[n^{k} * {d \choose d-k} \bigg] \]
&lt;/p&gt;

&lt;p&gt;
Then we have:
\[ { d \choose d-k } = \frac{d!}{k!(d-k)!} = { d \choose k } \]
&lt;/p&gt;

&lt;p&gt;
\[ \therefore s(l, n) = n! * \sum_{k=0}^{d} \bigg[n^{k} * {d \choose k} \bigg],
l \geq n \]
&lt;/p&gt;

&lt;p&gt;
This can be simplified with the binomial theorem identity, with n = d, a = 1, b
= n.
\[ \sum_{i=0}^{n} {n \choose i} a^{n-i}b^{i} = (a+b)^n \]
&lt;/p&gt;

&lt;p&gt;
\[ \therefore s(L, n) = n! * (n+1)^d \]
&lt;/p&gt;

&lt;p&gt;
And reverting the substitutions
\[ \therefore s(L, n) = n! * (n+1)^{(L-n)} \]
&lt;/p&gt;

&lt;p&gt;
And adding back in the case for l &amp;lt;= n.
\[ \therefore s(L, n) = \begin{cases}
      l! &amp;amp; l &amp;lt;= n \\
      n! * (n+1)^{L-n} &amp;amp; otherwise
   \end{cases} \]
&lt;/p&gt;

&lt;p&gt;
Which… FINALLY gives us the the answer! Phew!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description><category>juggling</category><category>math</category><guid>https://imois.in/posts/jack-boyces-siteswap-questions/</guid><pubDate>Mon, 06 May 2019 18:47:08 GMT</pubDate></item><item><title>Procedural Animation 2: Functions</title><link>https://imois.in/posts/procedural-animation-2-functions/</link><dc:creator>Oisin Carroll</dc:creator><description>&lt;div id="outline-container-org8ca987b" class="outline-2"&gt;
&lt;h2 id="org8ca987b"&gt;Intro&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8ca987b"&gt;
&lt;p&gt;
In this second section, I wanted to talk about functions… And how to take simple
movements and build more complex animations from them. Be warned: &lt;i&gt;Here be graphs&lt;/i&gt;.
&lt;/p&gt;

&lt;p&gt;
We'll be using the idea of &lt;b&gt;State&lt;/b&gt;, &lt;b&gt;Update&lt;/b&gt;, &lt;b&gt;Apply&lt;/b&gt; from &lt;a href="https://imois.in/posts/procedural-animation-1-state-machines/"&gt;Part 1&lt;/a&gt; here too. If
you haven't read that, you might want to start there!
[./procedural-animation-1-state-machines/][Part 1]] here too. If
&lt;/p&gt;

&lt;p&gt;
And finally, all of the animations are running in javascript canvas, so you can open the
source code in the inspector or find it on &lt;a href="https://imois.in/posts/https:/github.com/oisincar/imois.in/tree/src/files/assets/js/procedural_animation"&gt;my github for the site!&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge6b7a83" class="outline-2"&gt;
&lt;h2 id="orge6b7a83"&gt;Bouncing ball&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge6b7a83"&gt;
&lt;p&gt;
How to make this?
&lt;/p&gt;

&lt;script src="https://imois.in/assets/js/procedural_animation/BouncingBalls.js"&gt;&lt;/script&gt;&lt;div class="figure"&gt;
    &lt;canvas id="balls0" class="light_border" width="400" height="300"&gt; Your browser sucks :c. &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Anim 1:&lt;/span&gt; Moving the ball&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt; new BouncingBalls('balls0', 0, 1); &lt;/script&gt;&lt;p&gt;
For the &lt;b&gt;State&lt;/b&gt;, we can just have a single number that varies from 0 to 1:
The percentage through the animation we are so far.
&lt;/p&gt;

&lt;p&gt;
This means our &lt;b&gt;Update&lt;/b&gt; can turn the elapsed time into a percentage value and
add it to the &lt;b&gt;State&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
And our &lt;b&gt;Apply&lt;/b&gt; can move the ball based on the state variables, and draw it. For
this, we only need to change the y coordinate:
&lt;/p&gt;

&lt;p&gt;
y = state*k, where k a scaling value for how far the ball moves.
&lt;/p&gt;


&lt;p&gt;
In code this looks like:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// CONFIG:&lt;/span&gt;
&lt;span class="c1"&gt;// 'scale in time', length of animation&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;_duration&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;5.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// 'scale in space', distance ball moves&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;_dist&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;40.0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// 'offset in space'&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Vector2&lt;/span&gt; &lt;span class="n"&gt;_offset&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Vector2&lt;/span&gt;&lt;span class="p"&gt;(..);&lt;/span&gt;

&lt;span class="c1"&gt;// STATE:&lt;/span&gt;
&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;dt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// dt is the change in time.&lt;/span&gt;
    &lt;span class="c1"&gt;// UPDATE state:&lt;/span&gt;
    &lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;dt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;_duration&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// 1_|&lt;/span&gt;
    &lt;span class="c1"&gt;//   | /| /| /| /|....&lt;/span&gt;
    &lt;span class="c1"&gt;// 0_|/ |/ |/ |/ |&lt;/span&gt;

    &lt;span class="c1"&gt;// APPLY&lt;/span&gt;
    &lt;span class="n"&gt;ball&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_offset&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_dist&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The update line can be a bit confusing, but might make more sense when split up a bit more.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;dt&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;_duration&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Equilivent to (all of):&lt;/span&gt;
&lt;span class="c1"&gt;// The change in how far we are through the animation.&lt;/span&gt;
&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;dPerc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dt&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;_duration&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// Added to _animationPerc&lt;/span&gt;
&lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;dPerc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// And wrap back to 0 if we're &amp;gt; 1;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
We're working out how much further we are through the animation (```dPerc```)
which is our change it time divided by the duration of the animation. Say our
animation is 2 seconds long, and 1 second just elapsed… We're now half-way
further through than before.
&lt;/p&gt;

&lt;p&gt;
It might be helpful to think of the shape this variable (or all variables) make over time. A
lot of these animations can be thought of as the &lt;b&gt;Apply&lt;/b&gt; function reshaping the &lt;b&gt;State&lt;/b&gt; variables.
&lt;/p&gt;



&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/procedural_anim/animation_perc.png" alt="animation_perc.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 1: &lt;/span&gt;The shape of _animationPerc over time, where d is the duration of the animation, makes a sawtooth shape.&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;
In this example, our &lt;b&gt;Apply&lt;/b&gt; function just scales the &lt;b&gt;State&lt;/b&gt; by _dist. This is
then the y offset of the ball for that frame, as shown in the animation above.
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/procedural_anim/animation_apply1.png" alt="animation_apply1.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 2: &lt;/span&gt;Here, the input &lt;b&gt;State&lt;/b&gt; (Blue), is scaled to give the ball's positional offset by the &lt;b&gt;Apply&lt;/b&gt; function (Orange).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org53cfa07" class="outline-2"&gt;
&lt;h2 id="org53cfa07"&gt;Different Applications (heh)&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org53cfa07"&gt;
&lt;p&gt;
By just changing the &lt;b&gt;Apply&lt;/b&gt; function here, we can get a variety of different
movements. We can think of these movements as transformations of the origional
&lt;b&gt;State&lt;/b&gt; graph, since this is the only input.
&lt;/p&gt;

&lt;p&gt;
First lets move the ball up and down in wave like this…
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;canvas id="balls1" class="light_border" width="400" height="300"&gt; Your browser sucks :c. &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Anim 2:&lt;/span&gt; Wavey ball&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt; new BouncingBalls('balls1', 1, 1); &lt;/script&gt;&lt;p&gt;
Here, since \(sin(x)\) has a period of \(2*\pi\), we need to scale our state
variable by that so it loops properly.
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/procedural_anim/animation_apply1.png" alt="animation_apply1.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 3: &lt;/span&gt;Our state (Blue) compared to the wavey output of the ball (Orange) (Not to scale).&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
In code, this is as easy as:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// APPLY&lt;/span&gt;
&lt;span class="n"&gt;ball&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PI&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_animationPerc&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
By doing this to both the x and y axis at the same time, offset by a bit, we can get a circle!
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;canvas id="balls2" class="light_border" width="400" height="300"&gt; Your browser sucks :c. &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Anim 3:&lt;/span&gt; Circles&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt; new BouncingBalls('balls2', 2, 1); &lt;/script&gt;&lt;p&gt;
Which, again, in code is just:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// APPLY&lt;/span&gt;
&lt;span class="n"&gt;ball&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PI&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_animationPerc&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;ball&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PI&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_animationPerc&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// NOTE Equilivent to: ball.y = sin(2 * Math.PI * _animationPerc + Math.PI);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This idea can be taken much further, and leads to some really cool movements!
The &lt;a href="https://imois.in/posts/https:/en.wikipedia.org/wiki/Lissajous_curve"&gt;Lissajous Curves&lt;/a&gt; are created when you scale the x and y parts differently in
a way very similar to above ^. That's a whole different blog post though!
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/procedural_anim/1lissajous.gif" alt="1lissajous.gif" width="400px"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 4: &lt;/span&gt;The different shapes that can be made by scaling the inputs to sin/cos into different ratios. If these were animated like the ball above, the ball would follow the shape.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8a48cff" class="outline-2"&gt;
&lt;h2 id="org8a48cff"&gt;Zigzag&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8a48cff"&gt;
&lt;p&gt;
This is a slighly harder example for the idea of manipulating function shapes.
&lt;/p&gt;

&lt;p&gt;
We start off with our input shape as before… And keeping in mind our goal output shape (to get
the animation above).
&lt;/p&gt;

&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/procedural_anim/zigzag0.png" alt="zigzag0.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 5: &lt;/span&gt;Input _animationPerc (Blue), compared to the shape we need (Orange).&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
We can perform several steps to transform it into the right shape… Scaling it
up by 2 and moving it down by 1 (Orange). Then we can take the absolute value of
this (Green).
&lt;/p&gt;

&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/procedural_anim/zigzag1.png" alt="zigzag1.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 6: &lt;/span&gt;Input (Blue), scaled &amp;amp; transformed (Orange), result (Green)&lt;/p&gt;
&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// APPLY&lt;/span&gt;
&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;zigzag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Mathf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;ball&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;zigzag&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_dist&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org20d92d8" class="outline-2"&gt;
&lt;h2 id="org20d92d8"&gt;Bouncing balls&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org20d92d8"&gt;
&lt;p&gt;
In order to create a realistic bounce, we have to first construct the right
shape function again. Without delving into the physics of it, we're looking for
a Parabola: Some function of \(t^2\).
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/procedural_anim/bounce0.png" alt="bounce0.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 7: &lt;/span&gt;Input (Blue), vs bounce shape (Orange)&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Interestingly, we can get this shape from our zigzag before, by applying an
extra transformation: 1-zigzag&lt;sup&gt;2&lt;/sup&gt;.
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;canvas id="balls4" class="light_border" width="400" height="300"&gt; Your browser sucks :c. &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Anim 5:&lt;/span&gt; Bouncing balls&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt; new BouncingBalls('balls4', 4, 1); &lt;/script&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// APPLY&lt;/span&gt;
&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;zigzag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Mathf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;_animationPerc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;ball&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;zigzag&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;zigzag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_dist&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org99e192d" class="outline-2"&gt;
&lt;h2 id="org99e192d"&gt;More Ideas&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org99e192d"&gt;
&lt;p&gt;
We can clamp zigzag so it's 1 for some time, which means
the ball will sit on the ground for a bit… By animating the scaling too, maybe this could
be an animation for a slime NPC?
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/procedural_anim/bounce1.png" alt="bounce1.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 8: &lt;/span&gt;Basic zigzag curve (Blue), zigzag/0.8 and clamped between 0 and 1 (Orange), and finally the output shape - bouncing ball with a pause (Green).&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
And how it looks animated…
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;canvas id="balls5" class="light_border" width="400" height="300"&gt; Your browser sucks :c. &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Anim 6:&lt;/span&gt; Bouncing balls&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt; new BouncingBalls('balls5', 5, 1); &lt;/script&gt;&lt;p&gt;
And also we can have loads of balls by just adding an offset for the &lt;b&gt;State&lt;/b&gt;
value to each one! With some polish this could maybe make a kind of snake creature for a game…
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;canvas id="balls6" class="light_border" width="400" height="300"&gt; Your browser sucks :c. &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Anim 7:&lt;/span&gt; Bouncing balls&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt; new BouncingBalls('balls6', 6, 10); &lt;/script&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org567db22" class="outline-2"&gt;
&lt;h2 id="org567db22"&gt;Other applications&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org567db22"&gt;
&lt;p&gt;
While here, I've only done animations by moving things, it's also possible to
animate rotations, shaders, skeletons, and more with exactly the same ideas.
&lt;/p&gt;

&lt;p&gt;
Tune in for part 3 when I'll cover a more complicated idea: Using
gradient descent for solving constraints in procedural animation (but with fun
interactive animations!!).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description><category>animation</category><category>gamedev</category><category>programming</category><guid>https://imois.in/posts/procedural-animation-2-functions/</guid><pubDate>Sat, 27 Apr 2019 23:00:48 GMT</pubDate></item><item><title>Procedural Animation 1: State Machines</title><link>https://imois.in/posts/procedural-animation-1-state-machines/</link><dc:creator>Oisin Carroll</dc:creator><description>&lt;div id="outline-container-org8444c54" class="outline-2"&gt;
&lt;h2 id="org8444c54"&gt;Intro&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8444c54"&gt;
&lt;p&gt;
This is the first in a 3 part series on procedural animation, all taken from a talk
I gave in January of 2019. The posts ramp up in complexity, and I've tried to make
the animations interactive where possible!
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;This first post justifies and covers a general mentality I have for working on
procedural animations, and applies it to a simple example.&lt;/li&gt;
&lt;li&gt;
&lt;a href="https://imois.in/posts/procedural-animation-2-functions/"&gt;The second post&lt;/a&gt; gives a more powerful and harder tool - talking about function
shapes, and how you can build more complex behavour by combining simple movements.&lt;/li&gt;
&lt;li&gt;The third and final post (coming soon) covers inverse kinematics, and generally how to
approximate solutions much harder problems using gradient descent.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
All of the animations are running in javascript canvas, so you can open the
source code in the inspector or find it on &lt;a href="https://github.com/oisincar/imois.in/tree/src/files/assets/js/procedural_animation"&gt;my github for the site!&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4c7a2d2" class="outline-2"&gt;
&lt;h2 id="org4c7a2d2"&gt;Differences vs traditional animation.&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org4c7a2d2"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;Advantages:
&lt;ul class="org-ul"&gt;
&lt;li&gt;Greater (infinite?) variety.
Simulate large numbers easily.&lt;/li&gt;
&lt;li&gt;Can react to player/ world better.&lt;/li&gt;
&lt;li&gt;When done well: More realistic.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;

&lt;li&gt;Disadvantages:
&lt;ul class="org-ul"&gt;
&lt;li&gt;Loss of control. Can be harder to tweak.&lt;/li&gt;
&lt;li&gt;Hard to get very charachterful movement. Can look robotic
(Unless that's intentional…)&lt;/li&gt;
&lt;li&gt;When it breaks it often breaks hard.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgffa46c7" class="outline-2"&gt;
&lt;h2 id="orgffa46c7"&gt;State, Update &amp;amp; Apply&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgffa46c7"&gt;
&lt;p&gt;
This is the core of how I approach these animations. I find it's helpful to try
and break down the system into 3 parts - State, Update, and Apply. These
systems can very easily become hard to tweak and work with, and this is just one
tool that might help with that.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;
&lt;b&gt;State&lt;/b&gt;:
&lt;ul class="org-ul"&gt;
&lt;li&gt;One or more variables, no logic.&lt;/li&gt;
&lt;li&gt;All we need to know to draw a frame&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;b&gt;Update&lt;/b&gt;:
&lt;ul class="org-ul"&gt;
&lt;li&gt;Changes (only) state variables on each frame or update cycle.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;b&gt;Apply&lt;/b&gt;:
&lt;ul class="org-ul"&gt;
&lt;li&gt;Move and/or draw stuff according to state.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
Each part can be thought about separately, and by moving the state into a clear
separate variable the system becomes much easier to reason about. Animations
won't go out of sync, and it's to debug as you can just view and edit the state directly.
&lt;/p&gt;

&lt;p&gt;
Anyway… Lets look at an example!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org34b5c21" class="outline-2"&gt;
&lt;h2 id="org34b5c21"&gt;Example: Light&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org34b5c21"&gt;
&lt;p&gt;
State machines are one of the simplest forms of procedural animation. The idea
is there is a single 'state' we're in, and also a set of
rules for why/ when we change state. State machines are often used in game AI -
where states might be { &lt;b&gt;Defend&lt;/b&gt;, &lt;b&gt;Rush&lt;/b&gt;, &lt;b&gt;Flank&lt;/b&gt; }, or for a character: { &lt;b&gt;Falling&lt;/b&gt;,
&lt;b&gt;Walking&lt;/b&gt;, &lt;b&gt;Sprinting&lt;/b&gt;, &lt;b&gt;Attacking&lt;/b&gt; }.
&lt;/p&gt;

&lt;p&gt;
Here we've just got a light, our &lt;b&gt;State&lt;/b&gt; is one of: { &lt;b&gt;On&lt;/b&gt;, &lt;b&gt;Off&lt;/b&gt; }.
&lt;/p&gt;

&lt;div class="figure"&gt;
    &lt;canvas id="lightswitch" class="light_border" width="400" height="300"&gt; Your browser sucks :c. &lt;/canvas&gt;&lt;p&gt;&lt;span class="figure-number"&gt;Anim 1:&lt;/span&gt; Randomly flickering light.&lt;/p&gt;
&lt;/div&gt;
&lt;script src="https://imois.in/assets/js/procedural_animation/LightSwitch.js"&gt;&lt;/script&gt;&lt;p&gt;
The second part of State, Update, Apply: &lt;b&gt;Update&lt;/b&gt;, is also simple. We randomly
choose to either stay in the current state or move to the other. I found
a \(98\%\) chance to stay &lt;b&gt;On&lt;/b&gt; and a \(93\%\) chance to stay &lt;b&gt;Off&lt;/b&gt; works decently.
&lt;/p&gt;

&lt;p&gt;
We can view the state and the transitions as a graph, where the arrows denote
probabilities.
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://imois.in/images/procedural_anim/light_state.png" alt="light_state.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="figure-number"&gt;Figure 1: &lt;/span&gt;Light state diagram&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
And finally, our Apply section simply determines if we should draw a circle that
frame, or leave the frame blank.
&lt;/p&gt;

&lt;p&gt;
Overall, our code looks like this…
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// STATE&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;_on&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;dt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// UPDATE:&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_on&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;Random&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mf"&gt;0.98&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="n"&gt;_on&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;_on&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;Random&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mf"&gt;0.93&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="n"&gt;_on&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// APPLY:&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_on&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
	&lt;span class="c1"&gt;// Draw here!!&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Tune in next time for some more interesting examples!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description><category>animation</category><category>gamedev</category><category>programming</category><guid>https://imois.in/posts/procedural-animation-1-state-machines/</guid><pubDate>Thu, 25 Apr 2019 23:00:48 GMT</pubDate></item></channel></rss>