#+BEGIN_COMMENT
.. title: Procedural Animation 3: Gradient Descent
.. slug: procedural-animation-3-gradient-descent
.. date: 2019-05-05 00:00:50 UTC+00:00
.. tags: animation, programming, gamedev, math
.. category:
.. link:
.. has_math: true
.. description: Animating arms and tenticles with math!
.. type: text
#+END_COMMENT

#+BEGIN_SRC python :session :results file :exports none
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import numpy as np

path = "../images/procedural_anim/"

def savePlt(filename):
    plt.savefig(path + filename)
    return path+filename # return this to org-mode
#+END_SRC
#+RESULTS:

* Intro
#+BEGIN_EXPORT html
<script src="http://visjs.org/dist/vis.js"></script>
<script src="../assets/js/procedural_animation/Global.js"></script>
<script src="../assets/js/procedural_animation/Arm.js"></script>
<script src="../assets/js/procedural_animation/ArmCanvas.js"></script>
<script src="../assets/js/procedural_animation/Graph.js"></script>
#+END_EXPORT

#+REVEAL_EXTRA_CSS: https://code.jquery.com/ui/1.10.2/themes/smoothness/jquery-ui.css

In this second section, we'll cover how to solve harder problems that don't
necessarily have a single solution, or ones that have solutions that can't be
written as an equation of known variables.

We'll be using the idea of *State*, *Update*, *Apply* from [[./procedural-animation-1-state-machines/][Part 1]] here too. If
you haven't read that, you might want to start there!

You might also want to check out [[./procedural-animation-2-functions][Part 2]], where we went over how to build up more
complex movement by combining functions of state.

And finally, all of the (interactive!) animations here are running in javascript canvas, so you can open the
source code in the inspector or find it on [[https://github.com/oisincar/imois.in/tree/src/files/assets/js/procedural_animation][my github for the site!]]

* What we'll make!
These tenticles/ arms/ vines might make a fun enemy or background in a game, but
also demonstrate an idea that can be used to solve all kinds of problems! The
same idea (gradient descent) is the backbone of all modern AI... And all you
need to understand it is a basic knowledge of derivitives.

#+BEGIN_EXPORT html
<div class="figure">
    <!-- Arm -->
    <canvas id="intro-demo-arms" class="light_border" width="400" height="300">
        Your browser doesn't support html5 canvas :c.
    </canvas>
    <p><span class="figure-number">Anim 1:</span> Reaching arms with 20 and 100 segments. Drag to move the ball!</p>
</div>
#+END_EXPORT
#+BEGIN_SRC inline-js
class GradientDescentLongChain {

    constructor(id) {
        var self = this;

        var armC = new ArmCanvas(
            document.getElementById(id),
            function(){self.finished = false;});

        this.arm = new Arm(20, 300, -250);
        this.arm2 = new Arm(100, 100, -50);

        armC.addArm(this.arm);
        armC.addArm(this.arm2);

        // Double arm length
        this.arm._lengths = this.arm._lengths.map(function(x) { return x*1.7; });
        this.arm2._angles = this.arm2._angles.map(function(x) { return 0; });

        var doUpdate = true;
        if (doUpdate)
            setInterval(function() { self.update(); }, self.interval);
    }

    improve(arm) {
        // var grads = this.arm.calculateCurrentGradients();
        var grads = arm.calculateCurrentGradientsSq();

        // Update arm angles!
        for (var i = 0; i < grads.length; i++) {
            arm.changeAngle(i, -grads[i]*0.00001);
        }

        // If we're now close enough, don't update til we have to again.
        if (arm.getCurrentError() < 0.05) {
            return true;
        }
        return false;
    }

    update() {
        // Only do stuff if we're not already at the target.
        if (!this.finished) {
            // Finished if both arms are finished
            var a1 = this.improve(this.arm);
            var a2 = this.improve(this.arm2);
            this.finished = a1 && a2;
        }
    }
}

var b = new GradientDescentLongChain('intro-demo-arms');
#+END_SRC

* The problem: Kinematics
Generally, (and according to google) kinematics is a branch of mechanics that
deals with the features or properties of the motion of an object. It's often
refered to as the "Geometry of Motion". For charachter animation, we usually
deal with Kinematics of Simple Chains - or limbs...

For a given arm, *Forward Kinematics* is working out where the hand (or end) is
in space given the angles between the shoulder, and upper and lower arms. The
opposite of this, called *Inverse Kinematics* (IK), is where you have a fixed
target point and instead want to choose the same angles so the hand is as close
to it as possible.

- *Forward Kinematics:* :: Your upper arm is at $\alpha$ to your torso, and your
     upper arm is $\beta$ to your lower arm, where is your hand?

- *Inverse Kinematics:* :: You want to reach for a ball infront of you, what
     angles should you have at your shoulder and elbow?

We're going to look at the second one. Inverse Kinematics are used for all kinds
of charachter animation, robotics, and predicting people's location in VR. It'd
be pretty useful to have a way to solve it!

#+BEGIN_EXPORT html
<div class="figure">
    <span class="align_all">
        <div>
            <!-- Arm -->
            <canvas id="twolinkarmandgraph" class="light_border" width="400" height="300">
                Your browser doesn't support html5 canvas :c.
            </canvas>

            <!-- Sliders -->
            <span class="slider_row">
                <span class="slider_label">Shoulder Angle (a)</span>
                <span id="ang1" class="flat-slider"></span>
                <span type="text" id="ang1val" class="slider_text"></span>
            </span>

            <span class="slider_row">
                <span class="slider_label">Elbow Angle (b)</span>
                <span id="ang2" class="flat-slider"></span>
                <span type="text" id="ang2val" class="slider_text"></span>
            </span>
        </div>
    </span>
    <p><span class="figure-number">Anim 1:</span> The problem: Trying to reach for the ball by changing the angles of both joints. How can we find these angles?</p>
</div>
#+END_EXPORT
#+BEGIN_SRC inline-js
{
    function UpdateGraph() {}
    // Create an arm in that space
    var armC = new ArmCanvas(document.getElementById('twolinkarmandgraph'), UpdateGraph);
    armC.targetX = 27;
    armC.targetY = 13;

    var arm = new Arm(2);
    armC.addArm(arm);

    this.arm = arm;

    // slider
    $("#ang1").slider({
        min: 0,
        max: 180,
        values: [arm.getAngle(0)],
        slide: function(event, ui) {
            $("#ang1val").text(ui.values[0] + "째")
            arm.setAngle(0, ui.values[0]);
        }
    });
    $("#ang1val").text(arm.getAngle(0) + "째");

    $("#ang2").slider({
        min: -160,
        max: 160,
        values: [arm.getAngle(1)],
        slide: function(event, ui) {
            $("#ang2val").text(ui.values[0] + "째");
            arm.setAngle(1, ui.values[0]);
        }
    });
    $("#ang2val").text(arm.getAngle(1) + "째");
}
#+END_SRC

* Simple arms in 2d
For the 2D case, and when there's two joints in the arm, there are (usually) two solutions - an
'elbows up' position, and an 'elbows down' one.

Unfortunately if the target is
too far away there is no way to reach, and similarly if the upper and lower
arms are different lengths, then there's also no solution.

It's possible to work out these two angles with coordinate geometry or a bit of
trig, as long as you have the lengths of both arm segments and the target
location. However, as there's a million other gamedev sites, robotics courses,
and random medium posts, I'll won't explain it here again. It is a fun problem
though! I'd recommend giving it a go - it's hard to spot but doesn't require any
hard maths.

TODO: Link src...

It's also worth noting problems and limbs in 3D can be solved using the same 2D algorithm
with one trick: An 'elbow target'. We add a point that, given the choice, the
elbow will be as near to as possible. This (interestingly) causes all 5 points: Shoulder, Elbow,
Hand, Hand Target, and Elbow Target to all lie in the same plane. We can take
the plane defined by the fixed points: Shoulder, Hand Target, and Elbow Target
and solve the problem in 2d on that plane. This is how a lot of kinematics in
games is done.

* Harder problems?
It's not possible to solve harder problems using the same idea however, if you
add an extra segment to the arm there suddenly isn't a way to find solutions.
