<!DOCTYPE html>
<html prefix="" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Animating arms and tenticles with math!">
<meta name="viewport" content="width=device-width">
<title>Procedural Animation 3: Gradient Descent | im_oisin</title>
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../rss.xml">
<link rel="canonical" href="https://imois.in/posts/procedural-animation-3-gradient-descent/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><script src="https://code.jquery.com/jquery-1.12.4.js"></script><script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script><link href="https://code.jquery.com/ui/1.10.2/themes/smoothness/jquery-ui.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="author" content="Oisin Carroll">
<meta property="og:site_name" content="im_oisin">
<meta property="og:title" content="Procedural Animation 3: Gradient Descent">
<meta property="og:url" content="https://imois.in/posts/procedural-animation-3-gradient-descent/">
<meta property="og:description" content="Animating arms and tenticles with math!">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2019-11-26T00:22:20Z">
<meta property="article:tag" content="animation">
<meta property="article:tag" content="gamedev">
<meta property="article:tag" content="math">
<meta property="article:tag" content="programming">
</head>
<body>
    

    <header id="header" class="navbar"><div class="container">
            
    <div class="brand">

        <div class="brand-text">
            <a href="https://imois.in/" title="im_oisin" rel="home">
                im_oisin
            </a>
        </div>

        <a id="btn-toggle-nav" class="navbar-toggle">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
    </div>

            
    <nav class="navbar-collapse collapse"><ul class="nav">
<li><a href="../../archive.html">Archive</a></li>
                <li><a href="../../categories/">Tags</a></li>
                <li><a href="../../rss.xml">RSS feed</a></li>
    
    
    </ul></nav>
</div>
    </header><div class="header-padding"> </div>

    
    <div class="post-header">
        <div class="container">
            <div class="title">
                Procedural Animation 3: Gradient Descent
            </div>
        </div>
    </div>

    <div class="post-meta">
      <div class="container">
	<div class="meta clearfix">
	  <div class="authordate">
	    <time class="timeago" datetime="2019-11-26T00:22:20+00:00">2019/11/26</time>
	    

	    
          |  
        <a href="index.org" id="sourcelink">Source</a>

	  </div>
	  <div class="post-tags">
	    <div class="tag">
	      <a href="../../categories/animation/" rel="tag">animation</a>
	    </div>
	    <div class="tag">
	      <a href="../../categories/gamedev/" rel="tag">gamedev</a>
	    </div>
	    <div class="tag">
	      <a href="../../categories/math/" rel="tag">math</a>
	    </div>
	    <div class="tag">
	      <a href="../../categories/programming/" rel="tag">programming</a>
	    </div>
	  </div>
	</div>
      </div>
    </div>


    <div id="post-main" class="main">
        <div class="container">
        <div id="outline-container-org6be13d7" class="outline-2">
<h2 id="org6be13d7">Intro</h2>
<div class="outline-text-2" id="text-org6be13d7">
<script type="text/javascript" src="https://unpkg.com/vis-graph3d@latest/dist/vis-graph3d.min.js"></script><script src="../../assets/js/procedural_animation/Global.js"></script><script src="../../assets/js/procedural_animation/Arm.js"></script><script src="../../assets/js/procedural_animation/ArmCanvas.js"></script><script src="../../assets/js/procedural_animation/Graph.js"></script><script src="../../assets/js/procedural_animation/GradientDescent2Link.js"></script><script src="../../assets/js/procedural_animation/TwoLinkArmAndGraph.js"></script><p>
In this second section, we'll cover how to solve harder problems that don't
necessarily have a single solution, or ones that have solutions that can't be
written as an equation of known variables.
</p>

<p>
We'll be using the idea of <b>State</b>, <b>Update</b>, <b>Apply</b> from <a href="../procedural-animation-1-state-machines/">Part 1</a> here too. If
you haven't read that, you might want to start there!
</p>

<p>
You might also want to check out <a href="../procedural-animation-2-functions">Part 2</a>, where we went over how to build up more
complex movement by combining functions of state.
</p>

<p>
And finally, all of the (interactive!) animations here are running in javascript canvas, so you can open the
source code in the inspector or find it on <a href="https://github.com/oisincar/imois.in/tree/src/files/assets/js/procedural_animation">my github for the site!</a>
</p>
</div>
</div>

<div id="outline-container-org92be431" class="outline-2">
<h2 id="org92be431">What we'll make!</h2>
<div class="outline-text-2" id="text-org92be431">
<p>
These tenticles/ arms/ vines might make a fun enemy or background in a game, but
also demonstrate an idea that can be used to solve all kinds of problems! The
same idea (gradient descent) is the backbone of a huge amount of modern AI -
used to improve Google's results, autonomous cars, and more… And all you
need to understand it is a basic knowledge of derivitives.
</p>

<div class="figure">
    <!-- Arm -->
    <canvas id="intro-demo-arms" class="light_border" width="400" height="300">
        Your browser doesn't support html5 canvas :c.
    </canvas><p><span class="figure-number">Anim 1:</span> Reaching arms with 20 and 100 segments. Click &amp; Drag to move the ball!</p>
</div>
<script type="text/javascript">
class GradientDescentLongChain {

    constructor(id) {
        var self = this;

        var armC = new ArmCanvas(
            document.getElementById(id),
            function(){self.finished = false;});

        this.arm = new Arm(20, 300, -250);
        this.arm2 = new Arm(100, 100, -50);

        armC.addArm(this.arm);
        armC.addArm(this.arm2);

        // Double arm length
        this.arm._lengths = this.arm._lengths.map(function(x) { return x*1.7; });
        this.arm2._angles = this.arm2._angles.map(function(x) { return 0; });

        var doUpdate = true;
        if (doUpdate)
            setInterval(function() { self.update(); }, self.interval);
    }

    improve(arm) {
        // var grads = this.arm.calculateCurrentGradients();
        var grads = arm.calculateCurrentGradientsSq();

        // Update arm angles!
        for (var i = 0; i < grads.length; i++) {
            arm.changeAngle(i, -grads[i]*0.00001);
        }

        // If we're now close enough, don't update til we have to again.
        if (arm.getCurrentError() < 0.05) {
            return true;
        }
        return false;
    }

    update() {
        // Only do stuff if we're not already at the target.
        if (!this.finished) {
            // Finished if both arms are finished
            var a1 = this.improve(this.arm);
            var a2 = this.improve(this.arm2);
            this.finished = a1 && a2;
        }
    }
}

var b = new GradientDescentLongChain('intro-demo-arms');
</script>
</div>
</div>

<div id="outline-container-orgae8a1c4" class="outline-2">
<h2 id="orgae8a1c4">The problem: Kinematics</h2>
<div class="outline-text-2" id="text-orgae8a1c4">
<p>
Generally, (and according to google) kinematics is a branch of mechanics that
deals with the features or properties of the motion of an object. It's often
refered to as the "Geometry of Motion". For charachter animation, we usually
deal with Kinematics of Simple Chains - or limbs…
</p>

<p>
For a given arm, <b>Forward Kinematics</b> is working out where the hand (or end) is
in space given the angles between the shoulder, and upper and lower arms. The
opposite of this, called <b>Inverse Kinematics</b> (IK), is where you have a fixed
target point and instead want to choose the same angles so the hand is as close
to it as possible.
</p>

<dl class="org-dl">
<dt><b>Forward Kinematics:</b></dt>
<dd>Your upper arm is at \(\alpha\) to your torso, and your
upper arm is \(\beta\) to your lower arm, where is your hand?</dd>

<dt><b>Inverse Kinematics:</b></dt>
<dd>You want to reach for a ball infront of you, what
angles should you have at your shoulder and elbow?</dd>
</dl>
<p>
We're going to look at the second one. Inverse Kinematics are used for all kinds
of charachter animation, robotics, and predicting people's location in VR. It'd
be pretty useful to have a way to solve it!
</p>

<div class="figure">
    <span class="align_all">
        <div>
            <!-- Arm -->
            <canvas id="twolinkarmandgraph_smp" class="light_border" width="400" height="300">
                Your browser doesn't support html5 canvas :c.
            </canvas><!-- Sliders --><span class="slider_row">
                <span class="slider_label">Shoulder Angle (α)</span>
                <span id="ang1_smp" class="flat-slider"></span>
                <span type="text" id="ang1val_smp" class="slider_text"></span>
            </span>

            <span class="slider_row">
                <span class="slider_label">Elbow Angle (β)</span>
                <span id="ang2_smp" class="flat-slider"></span>
                <span type="text" id="ang2val_smp" class="slider_text"></span>
            </span>
        </div>
    </span>
    <p><span class="figure-number">Anim 1:</span> The problem: Trying to reach for the ball by changing the angles of both joints. How can we find these angles?</p>
</div>
<script type="text/javascript">
{
    function UpdateGraph() {}
    // Create an arm in that space
    var armC = new ArmCanvas(document.getElementById('twolinkarmandgraph_smp'), UpdateGraph);
    armC.targetX = 27;
    armC.targetY = 13;

    var arm = new Arm(2);
    armC.addArm(arm);

    this.arm = arm;

    // slider
    $("#ang1_smp").slider({
        min: 0,
        max: 180,
        values: [arm.getAngle(0)],
        slide: function(event, ui) {
            $("#ang1val_smp").text(ui.values[0] + "°")
            arm.setAngle(0, ui.values[0]);
        }
    });
    $("#ang1val_smp").text(arm.getAngle(0) + "°");

    $("#ang2_smp").slider({
        min: -160,
        max: 160,
        values: [arm.getAngle(1)],
        slide: function(event, ui) {
            $("#ang2val_smp").text(ui.values[0] + "°");
            arm.setAngle(1, ui.values[0]);
        }
    });
    $("#ang2val_smp").text(arm.getAngle(1) + "°");
}
</script>
</div>
</div>

<div id="outline-container-org9643a75" class="outline-2">
<h2 id="org9643a75">Simple arms in 2d</h2>
<div class="outline-text-2" id="text-org9643a75">
<p>
For the 2D case, and when there are only two joints in the arm, there are (usually) two solutions - an
'elbows up' position, and an 'elbows down' one.
</p>

<p>
Of course, there are cases where there are no solution. If the ball is out of
reach, for example.
</p>

<p>
It's possible to work out these two angles with coordinate geometry or a bit of
trig, as long as you have the lengths of both arm segments and the target
location. However, as there's a million other gamedev sites, robotics courses,
and random medium posts, so I'll won't explain it here again. It is a fun problem
though - I'd recommend giving it a go!
</p>

<p>
It's also worth noting problems and limbs in 3D can be solved using the same 2D algorithm/equation
with one trick: An 'elbow target'. We add a point that, given the choice, the
elbow will be as near to as possible. This (interestingly) causes all 5 points: Shoulder, Elbow,
Hand, Hand Target, and Elbow Target to all lie in the same plane. We can take
the plane defined by the fixed points: Shoulder, Hand Target, and Elbow Target
and solve the problem in 2d on that plane. This is how a lot of kinematics in
games is done.
</p>
</div>
</div>

<div id="outline-container-orgabf4867" class="outline-2">
<h2 id="orgabf4867">Harder problems.. I.e. Arms with more joints..?</h2>
<div class="outline-text-2" id="text-orgabf4867">
<p>
It's not possible to solve harder problems using the same idea however, if you
add an extra segment to the arm there suddenly isn't a way to find solutions
(mostly because there are now likely infinite solutions…).
</p>

<p>
This is what I wanted to write about… How can you find approximate or fast
solutions to a problem that's much harder to solve exactly, or find 'organic'
solutions to some problem that has a lot of possible solutions.
</p>

<p>
Instead of trying to find a solution instantly, we take the current position of
the arm and figure out how to improve it slightly. The solution is then
calculated itteratively, looping over and over either until we're not getting
any closer or we're within some distance.
</p>

<p>
Because we're only 3 dimensional creatures… The solution is easiest to
describe for arms with 2 joints… But the maths works for any number of joints.
</p>
</div>
</div>

<div id="outline-container-orgd98ccbc" class="outline-2">
<h2 id="orgd98ccbc">Forward Kinematics</h2>
<div class="outline-text-2" id="text-orgd98ccbc">
<p>
First, we need to work out where the end of our arm is… We write the angle at
the shouder as \(\alpha\), and at the elbow as \(\beta\). The length of the upper
arm is \(l1\), and forearm is \(l2\). I take the shoulder to be at \((0,0)\)
</p>

<p>
To do this, we can split it into 2 parts. The position of the elbow will be at:
</p>

\begin{align*}
Elbow_x &amp; = l1 * sin(\alpha) \\
Elbow_y &amp; = l1 * cos(\alpha)
\end{align*}

<p>
Then, similarly, we can work out the position of the hand relative to the elbow.
This is a little harder to see, but we can take the angle of the arm relative to
the ground (\(\beta - \alpha\)) and use the same trig formula.
</p>

\begin{align*}
Hand_x - Elbow_x &amp; = l2 * sin(\beta - \alpha) \\
Hand_y - Elbow_y &amp; = l2 * cos(\beta - \alpha)
\end{align*}

<p>
Then the position of the hand is simply the sum.
</p>

\begin{align*}
Hand_x &amp; = l1 * sin(\alpha) + l2 * sin(\beta - \alpha) \\
Hand_y &amp; = l1 * cos(\alpha) + l2 * cos(\beta - \alpha)
\end{align*}
</div>
</div>

<div id="outline-container-orga962146" class="outline-2">
<h2 id="orga962146">Distance function</h2>
<div class="outline-text-2" id="text-orga962146">
<p>
In order to perform gradient descent, we need a formula for the error we're
trying to reduce. This is the distance from our hand to our target. Ideally, we
want this distance to be 0, which'd mean our hand is exactly on the target.
</p>

<p>
The distance in x and y can be written from the above. Here \(|x|\) means the
absolute value of x, or the non-negative value of x.
</p>

\begin{align*}
Dist_x &amp; = | Target_x - (l1 * sin(\alpha) + l2 * sin(\beta - \alpha)) | \\
Dist_y &amp; = | Target_y - (l1 * cos(\alpha) + l2 * cos(\beta - \alpha)) |
\end{align*}

<p>
Then using pythagoras the distance is:
</p>

\begin{align*}
Dist = \sqrt{Dist_x^2 - Dist_y^2}
\end{align*}

<p>
We can look at this distance for any value of \(\alpha\) and \(\beta\). If we plot
\(\alpha\) and \(\beta\) on the x and y coordinates of a graph, and the
corrisponding distance the arm is from the target the z (vertical) axis, we can
view the distance as a shape.
</p>

<div class="figure">
    <span class="align_all">
        <div>
            <!-- Arm -->
            <canvas id="twolinkarmandgraph" class="light_border" width="600" height="300">
                Your browser doesn't support html5 canvas :c.
            </canvas><!-- Sliders --><span class="slider_row">
                <span class="slider_label">Shoulder Angle (α)</span>
                <span id="ang1" class="flat-slider"></span>
                <span type="text" id="ang1val" class="slider_text"></span>
            </span>

            <span class="slider_row">
                <span class="slider_label">Elbow Angle (β)</span>
                <span id="ang2" class="flat-slider"></span>
                <span type="text" id="ang2val" class="slider_text"></span>
            </span>

            <span class="slider_row">
                <span class="slider_label">Upper Arm Len</span>
                <span id="l1" class="flat-slider"></span>
                <span type="text" id="l1val" class="slider_text"></span>
            </span>

            <span class="slider_row">
                <span class="slider_label">Forearm Len</span>
                <span id="l2" class="flat-slider"></span>
                <span type="text" id="l2val" class="slider_text"></span>
            </span>

        </div>
        <div id="mygraph"></div>
    </span>
    <script> var a = new TwoLinkArmAndGraph(); </script><p><span class="figure-number">Anim 2:</span> The distance function for any of the shoulder and elbow angles.
    On the graph: Click to pan, scroll wheel to zoom, and mouse over to see the distance/angles at any point. Try messing around
    with the angles and arm lengths, or move the target ball!</p>
</div>

<p>
Each point on the surface corrisponds to some shoulder and elbow angles, and the
height (or colour) there corrisponds to the distance those angles put the hand
from the target. As you change the angles of the arms, you can see the graph
translate - the center of it shows the current elbow and shoulder angles.
</p>

<p>
You can make some neat patterns by tweaking the arm lengths and target position.
Try putting the ball on the base of the arm…
</p>

<p>
Our goal will be effectively to try and find the lowest point on this surface -
the angles there will bring our arm closest to our target ball.
</p>
</div>
</div>

<div id="outline-container-org31cb781" class="outline-2">
<h2 id="org31cb781">Gradient Descent</h2>
<div class="outline-text-2" id="text-org31cb781">
<p>
Without going too much into the nitty gritty, we can use the derivitive of this
distance function to improve our errors.
</p>

<p>
Write the distance as a function corrisponding to \(\alpha\) and \(\beta\) as \(Dist(\alpha, \beta)\).
</p>

<p>
Then we can consider the partial derivitive with respect to the angles.
</p>

\begin{align*}
\frac{\partial Dist}{\partial \alpha}
\end{align*}

<p>
This works out to a single value, and can be read/ thought of as 'how does the
distance to the target change when
I change α by a very small amount'.
</p>

<p>
For example if \(\frac{\partial Dist}{\partial \alpha}\) is positive, then
increasing \(\alpha\) will bring increase the distance. Decreasing \(\alpha\) then brings
hand towards the target. If the derivitive is negative, we
should instead increase \(\alpha\) by a small amount to improve our hand position.
This can be written as:
</p>

\begin{align*}
\alpha := \alpha - k * \frac{\partial Dist}{\partial \alpha}
\end{align*}

<p>
Here k is a small value, in the animations I have it set to 0.0001. This means
each update loop we update alpha to move the hand a little closer.
</p>

<p>
The maths is exactly the same for the elbow position:
</p>

\begin{align*}
\beta := \beta - k* \frac{\partial Dist}{\partial \beta}
\end{align*}

<p>
And for any number of limbs.
</p>

<p>
This method of improving is called 'gradient descent', because if we look at the
surface, each time we update we travel down the surface until we reach the bottom.
</p>

<p>
The demos just perform this update once per frame, but it's easy to completely
solve the system by running for more itterations.
</p>
</div>
</div>

<div id="outline-container-orgd2ae806" class="outline-2">
<h2 id="orgd2ae806">Implementation &amp; Extras</h2>
<div class="outline-text-2" id="text-orgd2ae806">
<p>
It might help to look through the source code for the animations (embedded into
this page), or available <a href="https://github.com/oisincar/imois.in/blob/master/assets/js/procedural_animation/Arm.js">here on Github</a>. You're free to lift this for anything,
the code's CC0!
</p>

<p>
Here's a bonus of what happens when you accidentally make 3 arms compete for who
renders at the same time…
</p>

<div class="figure">
    <!-- Arm -->
    <canvas id="twolinkgrad_arm_canvas_broken" class="light_border" width="500" height="400">
        Your browser doesn't support html5 canvas :c.
    </canvas><script>
      new GradientDescent2Link('twolinkgrad_arm_canvas_broken', 2);
      new GradientDescent2Link('twolinkgrad_arm_canvas_broken', 4);
      new GradientDescent2Link('twolinkgrad_arm_canvas_broken', 15);
    </script><p><span class="figure-number">Anim 3:</span> Glitchy movement, could be a neat effect for a Stranger Things monster..?</p>
</div>

<p>
Anyway, I hope this helped! Gradient descent is a very powerful tool for solving
any kind of problem if you're able to express it in a certain way. For more
procedural animation stuff, you might be interested in <a href="../procedural-animation-1-state-machines/">Part 1</a> where I looked at
some core ideas and a light animation, or <a href="../procedural-animation-2-functions">Part 2</a> with some more fancy function
ideas and shapes.
</p>
</div>
</div>

            
        
        <div data-title="Procedural Animation 3: Gradient Descent" id="isso-thread"></div>
        <script src="http://localhost:8080/js/embed.min.js" data-isso="http://localhost:8080/" data-isso-lang="en"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha256-SDRP1VVYu+tgAGKhddBSl5+ezofHKZeI+OzxakbIe/Y=" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']]}});
        </script>
</div>
    </div>

    
    <footer><div class="container">
            <div class="social">
                <div class="social-entry">
                    <a href="mailto:oisincar@gmail.com" target="_blank">
                        <i class="fa fa-envelope-o"></i>
                    </a>
                </div>


                <div class="social-entry">
                    <a href="https://github.com/oisincar" target="_blank">
                        <i class="fa fa-github"></i>
                    </a>
                </div>

                <div class="social-entry">
                    <a href="../../rss.xml" target="_blank">
                        <i class="fa fa-rss"></i> 
                    </a>
                </div>
            </div>
                <div class="copyright">
                    Contents © 2019         <a href="mailto:oisincar@gmail.com">Oisin Carroll</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
                    
                </div>
           
        </div>
    </footer><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-143421297-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-143421297-1');
</script><script src="../../assets/js/all-nocdn.js" type="text/javascript"></script>
</body>
</html>
